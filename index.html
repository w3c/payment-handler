<!DOCTYPE html>
<html>
<head>
  <title>Payment App API</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='utils.js' class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            shortName:  "payment-apps",
            edDraftURI:   "https://w3c.github.io/webpayments-payment-apps-api/",
            specStatus: "ED",
            editors: [
                {   name:       "Adrian Hope-Bailie",
                    url:        "https://github.com/adrianhopebailie",
                    company:    "Ripple",
                    companyURL: "https://ripple.com"
                },
                {   name:       "Tommy Thorsen",
                    url:        "https://github.com/tommythorsen",
                    company:    "Opera",
                    companyURL: "https://opera.com"
                },
                {   name:       "Adam Roach",
                    url:        "https://github.com/adamroach",
                    company:    "Mozilla",
                    companyURL: "https://mozilla.org"
                },
                {   name:       "Jason Normore",
                    url:        "https://github.com/jnormore",
                    company:    "Shopify",
                    companyURL: "https://shopify.com"
                },
                {   name:       "Ian Jacobs",
                    url:        "http://www.w3.org/People/Jacobs/",
                    company:    "W3C",
                    companyURL: "https://www.w3.org/"
                },
            ],

            useExperimentalStyles: true,
            license:      "w3c-software-doc",

            wg:           "Web Payments Working Group",
            wgURI:        "https://www.w3.org/Payments/WG/",
            wgPublicList: "public-payments-wg",
            wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83744/status",

            issueBase:    "https://github.com/w3c/webpayments-payment-apps-api/issues/",

            localBiblio:  {
                "PAYMENT-REQUEST-API": {
                    title:    "Payment Request API",
                    href:     "http://www.w3.org/TR/payment-request/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurray"
                    ],
                    status:   "FPWD"
                },
                "METHOD-IDENTIFIERS": {
                    title:    "Payment Method Identifiers",
                    href:     "https://www.w3.org/TR/payment-method-id/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurry"
                    ],
                    status:   "FPWD"
                }
            }
        };
    </script>
    <style>
        dt { margin-top: 0.75em; }
        table { margin-top: 0.75em; border-collapse:collapse; border-style:hidden hidden none hidden }
        table thead { border-bottom:solid }
        table tbody th:first-child { border-left:solid }
        table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
        li { margin-top: 0.5em; margin-bottom: 0.5em;}
    </style>
</head>
<body>
<section id='abstract'>
  <p>Payment Request API [[!PAYMENT-REQUEST-API]] provides
    a standard way to initiate payment requests from Web pages and
    applications. User agents implementing that API prompt the user
    to select a way to handle the payment request, after which
    the user agent returns a payment response to the originating site.
    This specification adds <strong>payment apps</strong>
    to that user experience. It defines how users
    register payment apps with user agents, how user agents present
    information about payment apps the user can select to handle the
    payment request, how the user selects a payment app, and how communication takes
    place between user agents and payment apps to fulfill the requirements of the
    underlying Payment Request API.</p>
</section>
<section id='sotd'>
    <p>The Web Payments Working Group maintains <a href="https://github.com/w3c/webpayments-payment-apps-api/issues">
        a list of all bug reports that the group has not yet addressed</a>.
        This draft highlights some of the pending issues that are still to
        be discussed in the working group. No decision has been taken on
        the outcome of these issues including whether they are valid. Pull
        requests with proposed specification text for outstanding issues
        are strongly encouraged.</p>
</section>
<section class='informative'>
  <h2>Introduction</h2>

  <p>The Web Payments Working Group seeks to streamline payments on the Web to
  help reduce payment "abandonment" and make it easier to use
  new payment methods on the Web. It has published the Payment Request
  API [[!PAYMENT-REQUEST-API]] as a standard way to initiate payment
  requests from Web pages and applications. This specification adds
    payment apps to that user experience. A payment app is software that
    enables the user to fulfill a payment request using the user's
    preferred payment method.</p>

    <p>This specification defines:</p>
    <ul>
      <li>How users register and unregister payment apps with the user agent (or other "mediator" that implements Payment Request API [[!PAYMENT-REQUEST-API]]).</li>
      <li>How the user agent matches payment methods supported by the payee with those enabled in registered payment apps.</li>
      <li>How merchants and other payees may recommend payment apps to the user.</li>
      <li>How the user agent presents information about payment apps to the user for selection.</li>
      <li>How the user agent invokes a payment app, communicates input/response data with it, and returns the response data to the underlying Payment Request API.</li>
    </ul>

  <p> Payment apps may be implemented in a variety of ways: as Web applications, native operating system applications,
    user agent extensions, built-in user agent components, interface-less Web services, or a combination. The scope of this specification is Web-based payment apps, which are implemented as service workers.</p>
</section>
<section id='conformance'>
    <p>
        This specification defines one class of products:
    </p>
    <dl>
        <dt><dfn>Conforming user agent</dfn></dt>
        <dd>
            <p>
                A <a>user agent</a> MUST behave as described in this specification
                in order to be considered conformant. In this specification, <a>user agent</a> means a <em>Web
                browser or other interactive user agent</em> as defined in [[!HTML5]].
            </p>
            <p>
                User agents MAY implement algorithms given in this
                specification in any way desired, so long as the end result is
                indistinguishable from the result that would be obtained by the
                specification's algorithms.
            </p>
            <p>
                A conforming Payment App API user agent MUST also be a
                <em>conforming implementation</em> of the IDL fragments
                of this specification, as described in the
                “Web IDL” specification. [[!WEBIDL]]
            </p>

            <aside class="note">
                This specification uses both the terms "conforming user agent(s)"
                and "user agent(s)" to refer to this product class.
            </aside>
        </dd>
    </dl>
</section>
<section id="dependencies">
  <h3>Dependencies</h3>
  <p>This specification relies on several other underlying specifications.</p>
    <dl>
        <!--
          <dt>Payment Request Architecture</dt>
          <dd>The term <dfn data-lt="payment method|payment methods">Payment Method</dfn>
	    is defined by the Payment Request Architecture document
        [[PAYMENT-ARCH]].</dd>
        -->
        <dt>Payment Request API</dt>
        <dd>The terms
            <dfn>PaymentRequest</dfn>, <dfn>PaymentResponse</dfn>,
            and
            <dfn>user accepts the payment request algorithm</dfn>
            are defined by the
            Payment Request API specification [[!PAYMENT-REQUEST-API]].</dd>
        <!--
        <dt>Payment Method Identifiers</dt>
        <dd>The terms <dfn data-lt="payment method|payment methods">payment method</dfn> and
            <dfn data-lt="payment method identifier|payment method identifiers">payment
            method identifier</dfn> are defined by the Payment Method
            Identifiers specification [[!METHOD-IDENTIFIERS]].</dd>
        -->
        <dt>HTML5</dt>
        <dd>The terms <dfn>global object</dfn>,<dfn>origin</dfn>, <dfn>queue a task</dfn>,
            <dfn>browsing context</dfn>, <dfn>top-level browsing
                context</dfn>, <dfn>structured clone</dfn>,
                <dfn>event handler</dfn>, <dfn>event handler event type</dfn>,
                <dfn>trusted event</dfn>,
                and <dfn>current settings object</dfn> are defined by
                [[!HTML5]].</dd>
            <dt>ECMA-262 6th Edition, The ECMAScript 2015 Language
                Specification</dt>
            <dd>The term <dfn>Promise</dfn>

        <!--
            , <dfn>internal slot</dfn>,
                <dfn><code>TypeError</code></dfn>, <dfn>JSON.stringify</dfn>,
                <dfn>JSON.parse</dfn>, <dfn><code>Array</code></dfn>,
                <dfn><code>type</code></dfn> and the <dfn>[[\GetOwnProperty]]</dfn>
                operation are
        -->
                is defined by [[!ECMA-262-2015]].
        <!--
                <p>This document uses the format <em>object</em>@[[\slotname]] to
                    mean the internal slot [[\slotname]] of the object
                    <em>object</em>.</p>
                <p>The term <dfn>JSON-serializable object</dfn> used in this
                    specification means an object that can be serialized to a string
                    using <a>JSON.stringify</a> and later deserialized back to an
                    object using <a>JSON.parse</a> with no loss of data.</p>
                <p>When instructed to <dfn>Trim</dfn>(<var>x</var>), a user agent
                    MUST behave as if [[!ECMA-262-2015]]'s
                    <code>String.prototype.trim()</code> function had been called on
                    the string <var>x</var>.</p>
        -->
            </dd>
            <dt>DOM4</dt>
            <dd>
            <!--
                The <code><dfn>Event</dfn></code> type and the terms <dfn>fire
                an event</dfn>, <dfn>dispatch flag</dfn>, <dfn>stop propagation
                flag</dfn>, and <dfn>stop immediate propagation flag</dfn> are
                defined by [[!DOM4]].
            -->
                <p><dfn>DOMException</dfn> and the following DOMException types
                    from [[!DOM4]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>AbortError</dfn></code></td>
                        <td>The operation was aborted</td>
                    </tr>
                    <tr>
                        <td><code><dfn>InvalidStateError</dfn></code></td>
                        <td>The object is in an invalid state</td>
                    </tr>
                    <!--
                    <tr>
                        <td><code><dfn>NotSupportedError</dfn></code></td>
                        <td>The payment method was not supported</td>
                    </tr>
                    -->
                    <tr>
                        <td><code><dfn>SecurityError</dfn></code></td>
                        <td>The operation is only supported in a secure context</td>
                    </tr>
                    <tr>
                        <td><code><dfn>OperationError</dfn></code></td>
                        <td>The operation failed for an operation-specific reason.</td>
                    </tr>
                </table>
            </dd>
            <dt>WebIDL</dt>
            <dd>
            <!--
                When this specification says to <dfn>throw</dfn> an error, the
                <a>user agent</a> must throw an error as described in [[!WEBIDL]].
                When this occurs in a sub-algorithm, this results in termination of
                execution of the sub-algorithm and all ancestor algorithms until
                one is reached that explicitly describes procedures for catching
                exceptions.
            -->
                <p>The following DOMException types from [[!WEBIDL]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>NotAllowedError</dfn></code></td>
                        <td>The request is not allowed by the user agent or the
                        platform in the current context.</td>
                    </tr>
                </table>
                </dd>
        <dt>Secure Contexts</dt>
        <dd>The terms <dfn>secure context</dfn> is defined by the Secure
          Contexts specification [[!POWERFUL-FEATURES]].</dd>
        <dt>URL</dt>
        <dd>The <dfn>URL</dfn> concept and <dfn>URL parser</dfn> are
            defined in [[!WHATWG-URL]].</dd>
        <dt>Fetch</dt>
        <dd>The terms <dfn>Fetch</dfn>, <dfn>Request</dfn>, <dfn data-lt="body">Request Body</dfn>, <dfn data-lt="method">Request
            Method</dfn>, <dfn>Header List</dfn>, <dfn>Response</dfn>,
            <dfn>Context</dfn> and <dfn>Network Error</dfn> are defined in
            [[!FETCH]].</dd>
        <dt>Service Workers</dt>
        <dd>The terms
          <dfn data-lt="service worker|service workers">service worker</dfn>
          <dfn>service worker registration</dfn>,
          <dfn>active worker</dfn>,
          <dfn>installing worker</dfn>,
          <dfn>waiting worker</dfn>,
          <dfn>handle functional event</dfn>,
          <dfn>extend lifetime promises</dfn>,
          and
          <dfn data-lt="scope url|scope urls">scope URL</dfn>
          are defined in [[SERVICE-WORKERS]].</dd>
    </dl>
</section>
<section id="model">
  <h2>Payment App Model and Design Considerations</h2>
  <p>This section describes the capabilities and limitations of this specification in functional terms.</p>
  <section>
    <h3>General Considerations</h3>
    <ul>
      <li>This specification builds on PaymentRequest API.</li>
      <li>It defines mechanisms that may be used to support Web-based payment apps. We anticipate that various platforms will offer proprietary alternatives to this specification (e.g., for payment app registration or invocation). Proprietary payment apps lie outside the scope of this specification.</li>
    </ul>
  </section>
  <section>
    <h3>Decoupling and Trust</h3>
    <ul>
<li>    A goal of this system is to decouple the payment methods used to pay from the software (payment apps) that implement those payment methods. By decoupling, merchants (and their payment service providers) can lower the cost of creating a checkout experience, users can have more choice in the software they use to pay, and payment app providers can innovate without imposing an integration burden on merchants.</li>
<li>User choice of payment apps that support a given payment method will depend in part on the willingness of the payment method owner to authorize other parties to implement their payment methods. For example, there may only be one payment app authorized to support a payment method owned by a company, while there may be many apps that support basic credit card payments or credit transfers.</li>
<li>    For privacy, we seek to limit information about the user's environment available to merchants without user consent. That includes which payment apps the user has registered. The merchant should not receive information about which payment app the user selected to pay unless the user consents to share that information. (When there is only one payment app for a given payment method that information is already publicly known.)</li>
<li>    Although decoupling relieves merchants of implementing some aspects of the checkout experience, one consequence is that they give up some degree of control. This was already the case for some payment methods, but for traditional card payments, merchants (or their PSPs) will be entrusting some portion of data collection to the user agent or third party payment apps.</li>
<li>The design therefore includes support for merchants to <a href="#summary-recommended-apps">recommend payment apps</a> and suggest the display order of payment methods. This specification does not constrain how user agents make use of this information, but provides guidance to user agent developers about taking into account both merchant and user preferences. </li>
<li> The user agent may use this combined preference information to:
  <ul>
    <li>   Filter payment apps (to matching payment methods)</li>
<li>        Order payment apps (according to merchant-specified order)</li>
<li>        Display recommended payment apps (according to merchant-specified order)</li>
    </ul>
</li>
</ul>
  </section>
  <section>
    <h3>Identification</h3>
    <ul>
      <li>A Payment App is identified by a Payment App Identifier (PAI).</li>
      <li>This specification defines service-worker based payment apps. The PAI is the service worker's “script URL” that, when dereferenced, returns the code of the service worker. <p class="issue">See a <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/48#issuecomment-261775283">counter-proposal</a> as part of <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/48">issue 48</a></p></li>
      <li>The user agent may make use of the origin information of the PAI in a variety of ways, including:
	<ul>
	  <li>        The origin information could enable user agents to provide the user with useful services when the user is browsing a site with the same origin (e.g., putting that payment app at the top of a list or otherwise highlighted).</li>
	  <li>        For a payment method with an associated origin, the user agent can do some (security) checks by comparing the origin of the payment method and any authorized payment app.</li>
	</ul>
      </li>	
    </ul>
  </section>
  <section>
    <h3>Registration and Unregistration</h3>
    <ul>
      <li>Registration provides a way for user agents to remain aware of the user's payment apps across transactions.</li>
      <li>In this specification, registration means registration of a service worker with the user agent.  Registration does <strong>not</strong> refer to how the user establishes a relationship with the payment service provider, for example by setting up an account with that
	provider.</li>
      <li>When a payment app is registered, the service worker adds an event listenter for "install" that is subsequently called. This install code uses <code>setManifest</code>
	to provide payment app manifest information&mdash; names, icons, etc.&mdash; to the user agent. This specification does not require that the payment manifest be independently addressable (e.g., in a file on the Web).</li>
      <li>A payment app that follows this specification must be registered
	before it can be used to make a payment. 
	<strong>Note:</strong> Registration is not
	necessarily a prerequisite to be able to use other types
	of payment apps (e.g., native payment apps).</li>
      <li>We expect registrations to happen at various times (e.g., outside and inside of checkout), and with differing levels of
          user consent to modify their configuration within the user agent. In general, explicit consent should not be required
          while the user is within the context of the payment request UI. Here are some examples:
        <ul>
          <li>Users visiting a Web site (e.g., merchant or bank) may wish to explicitly register payment apps, which would require explicit consent from the user.</li>
          <li>When the user selects a recommended payment app the user agent registers the payment app and may do so without additional user action or consent.</li>
          <li>When the user installs native payment app, registration could happen either through platform-specific mechanisms or through this standard API, without additional user action beyond installation.</li>
        </ul>
      </li>
      <li>The payment app manifest includes information about enabled payment methods, which is used later for matching payee-accepted payment methods. Service workers can provide updated payment manifest information, for example when the user stores or updates credentials, or the payment app is upgraded. Note: This specification does require payment apps to be able to respond to user agent queries for updated
          registration information. (See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/36">issue 36</a>.)</li>
      <li>It is important for merchants and users to be able to trust the
	authenticity of payment apps. A starting point is to rely on origin information (e.g., if a payment app is registered on a Web site). In contexts where origin binding is unavailable or insufficient, other mechanisms should be considered to help establish authenticity (e.g., origin-bound confirmation of a digital signature of a payment app).</li>
    </ul>
  </section>
  <section>
    <h3 id="summary-recommended-apps">Recommended Payment Apps</h3>
    <ul>
      <li>Payees may recommend payment apps that may be used for a given transaction. In some cases the user may have already registered these payment apps.</li>
      <li>To recommend a payment app, a merchant provides a payment app identifier (PAI), name, and icon information. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/79">issue 79</a> for discussion about how this may be done.</li>
      <li>When the user agent presents a recommended (unregistered) payment app for selection by the user, it uses merchant-provided information.</li>
      <li>In the case where the user has already registered a recommended payment app, the user agent may use merchant-provided
	information to complement information available from the
	payment app manifest or to present that payment app for
	selection in some special manner.
	<strong>Note:</strong> The Working Group
	is still discussing the display of information in the case
	of recommended payment apps already registered by the user.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Matching and Selection</h3>
    <ul>
      <li>When the user invokes the Payment Request API (e.g., by "pushing the Buy button"), the user agent presents a list of "matching" payment apps to the user for selection. Matching payment apps are those recommended by the merchant, and those registered by the user that support the merchant's accepted payment methods (including finer-grain acceptance filters from the merchant).</li>
      <li>In the case of a recommended payment app already registered by the user (determined by comparison of payment app identifiers), the user agent may present the app in some special way to highlight the merchant's recommendation.</li>
      <li>When the user selects a recommended unregistered payment app, the user agent registers it, using the provided payment app identifier to access the service worker code.</li>
      <li>The user agent may offer features to facilitate selection. For example, instead of merely displaying information about a payment app that supports cards, the user agent could display some representation of individual cards stored in the payment app. If the user can select an option directly, that could contribute to reducing the total number of required user actions. User agents might also enable the user to optimize payments using certain payment apps on certain Web sites. User experience optimizations such as these lie outside the scope of this specification.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Invocation and Response</h3>
    <ul>
      <li>Once the user has selected a payment app, the user agent activates the associated service worker code and provides the payment app with
        input data drawn from the Payment Request API. </li>
      <li>The user may interact with the payment app in a variety of ways to authorize payment, cancel the transaction,
          or carry out other activities supported by the payment app.</li>
      <li>This specification defines a means for the user agent to receive a response asynchronously once the user has
          authorized payment. The response becomes the response of the Payment Request API.</li>
      <li>This specification only describes communication between the
        user agent and the payment app. This includes an
        asynchronous mechanism for a payment app to return a payment
        response to the user agent. This specification does not address communication between the payee server and the payee Web app, or between
        the payment app and other parties (e.g., the payment app distributor, or directly to the merchant).</li>
    </ul>
  </section>
</section>

<section id="definitions">
  <h2>Definitions</h2>
  <div data-include="https://w3c.github.io/webpayments-ig/latest/common/terms.html"
       data-oninclude="restrictReferences">
  </div>

  <section>
  <h3>Payment App Implementation Technology</h3>
  <dl>
    <dt><dfn id="dfn-user-agent-based-payment-app"
         data-lt="user-agent-based payment app|user-agent-based payment apps">
    user agent-based payment app</dfn></dt>
    <dd>a <a>payment app</a> that runs in a <a>user agent</a>. User agent-based
    payment apps may elect to display a user interface, or to operate without
    any user interaction. This decision is made at runtime, and may vary based
    on criteria of the app's choosing (such as how long it has been since the
    user last authenticated themselves).</dd>

    <dt><dfn id="dfn-native-payment-app" data-lt="native payment app|native payment apps">native payment app</dfn></dt>
    <dd>a payment app built with the operating system default technology stack that uses non-Web technologies.</dd>
    <dt><dfn id="dfn-ignored-payment-app">ignored payment app</dfn></dt>
    <dd class="issue">An app that the user has configured to not be displayed, or that the user agent ignores for security reasons.</dd>
    <dt><dfn id="dfn-payment-app-identifier"
         data-lt="payment app identifier|payment app identifiers">
    payment app identifier</dfn></dt>
    <dd>
       A unique identifier for a <a>payment app</a> (e.g., from a <a>payment
       method</a> manifest file). This specification defines these identifiers
       as to be <a>service worker</a> <a>scope URLs</a>. As such, they are not
       expected to be dereferenced.
    </dd>
    <dt><dfn>payment app window</dfn></dt>
    <dd>
      A <a>service worker</a> <code>WindowClient</code> used by <a>user agent-based
      payment apps</a> to interact with the user when doing so is necessary to
      complete the payment transaction.
    </dd>
  </dl>
  <p class="note" title="Payment Apps in scope">
    The Web Payments Working Group intends for this specification to apply to any payment app that may be invoked by the user agent, whatever technologies have been used to implement the payment app.</p>
  </section>
  <section>
  <h3>Payment App Registration States</h3>
  <dl>
      <dt><dfn id="dfn-registered-payment-app">registered payment app</dfn></dt>
      <dd>a payment app that is "known" to the user agent for the purposes of the interactions described in this document.

      <div class="note" title="Platform-specific registration">
          This specification defines a registration mechanism. Other registration mechanisms might co-exist with this one
          (e.g., on some platforms there may be a way to register a payment app directly with the operating system).</div>
      </dd>
      <dt><dfn id="dfn-unregistered-payment-app">unregistered payment app</dfn></dt>
      <dd>a payment app that is not known to the user agent, either because it has never been registered, or because it has been unregistered.</dd>

	  <dt><dfn id="dfn-enabled-payment-app">enabled payment app</dfn></dt>
	  <dd>A <a>registered payment app</a> with at least one <a>enabled
	      payment method</a>.</dd>
  </dl>
  </section>
  <section>
  <h3>Payment App Selection States</h3>
  <dl>
    <dt><dfn id="dfn-matching-payment-app">matching payment app</dfn></dt>
    <dd>An <a>enabled payment app</a> that:
      <ul>
	<li>has at least one <a>enabled payment method</a> that the
	  <a>payee</a> accepts.</li>

	<li>is not an <a>ignored payment app</a>.</li>
      </ul>
    </dd>
      <dt><dfn id="dfn-recommended-payment-app">recommended payment app</dfn></dt>
      <dd>a payment app suggested by the payee or user agent that may be used to handle a specific payment request.</dd>
      <dt><dfn id="dfn-displayed-payment-app">displayed payment app</dfn></dt>
	  <dd>A <a>matching payment app</a> or <a>recommended payment app</a> with at least one matching payment method (i.e., presented by the user agent for user selection).</dd>
      <dt><dfn id="dfn-selected-payment-app">selected payment app</dfn></dt>
      <dd>the payment app selected by the user to make a payment, but not yet invoked.</dd>

      <dt><dfn id="dfn-invoked-payment-app">invoked payment app</dfn></dt>
      <dd>the <a>selected payment app</a> that the user agent has invoked (executed) and passed payment app input data.</dd>
  </dl>

  </section>
  <section>
  <h3>Payment Method Support</h3>
  <dl>
      <dt><dfn id="dfn-supported-payment-method">supported payment method</dfn></dt>
      <dd>a payment method that a payment app has been designed to support. This payment method may or may
          not currently be enabled. A payment app MAY support more than one payment method.</dd>

      <dt><dfn id="dfn-unsupported-method">unsupported payment method</dfn></dt>
      <dd>a payment method that cannot be enabled by a payment app. Updates to a payment app may cause an
          unsupported payment method to become supported, or vice-versa.</dd>

      <dt><dfn id="dfn-enabled-method">enabled payment method</dfn></dt>
      <dd>a supported payment method that a registered payment app is able to handle. The payment app must have at least
          one enabled payment method.
      <p class="note" title="Supported vs enabled Payment Methods">
          The difference between <strong>supported</strong> and <strong>enabled</strong> payment methods is one of design-time vs runtime consideration.
          A payment app supports all the payment methods it was designed to support; however at runtime only a subset
          may be enabled due to configuration or other runtime requirements that may not have been met for all
          supported payment methods.
      </p>
</dd>

  </dl>
  </section>
  <section>
  <h3>Payment App Invocation and Response Data</h3>
  <dl>
    <dt><dfn id="dfn-app-request">payment app request</dfn></dt>
    <dd>a request provided to the invoked payment app by the user agent to initiate a payment request. This request is a subset of the Payment Request.
    <p class="note" title="JSON serialization">
        The data passed between the user agent and the payment app will be serialized as JSON data.
    </p>
    </dd>
    <dt><dfn id="dfn-app-response">payment app response</dfn></dt>
    <dd>a response returned by an invoked payment app to the user agent, typically after payment authorization or other action
        taken through the payment app. This response, which will vary according to payment method, is then returned to the payee via
        the Payment Request API as part of the payment response.</dd>
  </dl>
</section>
</section>
<section id="overview">
  <h2>Overview of Service-Worker-Based Approach</h2>

<p>In this specification we use <a>service workers</a>
    to connect user agents with user agent-based payment apps. We do so for
    several reasons:</p>

    <ul>
      <li>
        Service workers provide a cleanly isolated execution context that allows
        the <a>payment app</a> to run with clean separation from the
        <a>payee</a> website.
      </li>
      <li>We can leverage the ways in which service workers already
          handle lifecycle management (registration, update, and removal of
          <a>payment apps</a>), enable offline use, etc.</li>
      <li>We can leverage service worker origins for security, especially
          when used in conjunction with origins associated with <a>payment
          method identifiers</a>.</li>
    </ul>

<p class="note">
  The use of service workers restricts <a>user agent-based payment apps</a> so
  that they must run only in secure contexts. The introduction of this
  restriction is deliberate, due to the sensitivity of the role that payment
  apps play. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/24">issue 24</a> for information about launching the payment app in a secure context.
</p>

<p>Here is the flow envisioned by this document:</p>
  <ol>
    <li>Through registration, a <a>service worker</a> is created and
        associated with <a>payment methods</a>
        (and associated metadata).</li>
    <li>When the <code>payment request API</code> is called, the user agent
        displays a list of registered service workers associated
        with matching payment methods (along with any other payment apps
        that may be available to the user agent).</li>
    <lI>When the user selects a <a>user agent-based payment
        app</a>, the corresponding <a>service worker</a> is activated, and
        it receives a <a>PaymentRequestEvent</a>.</li>
    <li>Once active, the <a>payment app</a> performs whatever steps are
        necessary to authenticate the user, process the payment, and return
        payment information to the <a>payee</a>. If interaction with the user
        is necessary, the <a>payment app</a> can open a <a>payment app
        window</a> for that purpose.</li>
    <li>Finally, once the <a>payment app</a> is finished with its processing, it
        resolves a <a>Promise</a> passed to it in the event. This causes the
        <code>Promise&lt;PaymentResponse&gt;</code> returned from
        <code>PaymentRequest.show()</code> to resolve.</li>
  </ol>
</section>
<section id="registration">
    <h2>
      Payment App Registration
    </h2>
    <section>
    <h3>
      Extensions to the <a>ServiceWorkerRegistration</a> interface
    </h3>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerRegistration</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <pre id="service-worker-registration-idl" class="idl">
        partial interface ServiceWorkerRegistration {
          readonly attribute PaymentAppManager paymentAppManager;
        };
      </pre>
  </section>
  <section id="payment-app-manager">
  <h2>
    <a>PaymentAppManager</a> interface
  </h2>
      <pre id="payment-app-manager-idl" class="idl">
      interface PaymentAppManager {
        Promise&lt;void&gt; setManifest(PaymentAppManifest manifest);
        Promise&lt;PaymentAppManifest&gt; getManifest ();
      };
      </pre>
      <section id="set-manifest">
      <h3>
        PaymentAppManager.setManifest()
      </h3>
        <p>
            The <code><dfn>setManifest</dfn></code> method is used to enable a
            service worker to process <a>payment requests</a>, and to set the
            properties associated with the <a>payment app</a>.
        </p>
        <p>The following algorithm provides an <dfn>extension point</dfn>: other
        specifications that add new members to the manifest are encouraged to
        hook themselves into this specification at this point in the
        algorithm.</p>
        <p>The <code>setManifest</code> method, when invoked,
        MUST run the following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            <a>Extension point</a>: if the user agent has custom steps to invoke
            when registering payment apps, execute these steps (possibly
            rejecting <var>promise</var> with a <code><a>DOMException</a></code>
            whose name is "<code><a>OperationError</a></code>") and terminate
            these steps.
            <div class="note">
              Through this <a>extension point</a> we seek to avoid
              <a href="https://annevankesteren.nl/2014/02/monkey-patch">issues
                related to monkey patching</a>.
            </div>
          </li>
          <li>
            Let <var>manifest</var> be the value of the <code>manifest</code>
            argument.
          </li>
          <li>
            If <var>manifest</var>.<code>canHandle</code> is present but is
            not set to an executable function, reject <var>promise</var> with
            a <code><a>DOMException</a></code> whose name is
             "<code><a>OperationError</a></code>" and terminate these steps.
          </li>
          <li>
            Let <var>registration</var> be the
            <code><a>PaymentAppManager</a></code>'s associated <a>service
            worker registration</a>.
          </li>
          <li>If <var>registration</var> has no <a>active worker</a>, run the following substeps:
            <ol>
              <li>If <var>registration</var> has no <a>installing worker</a> and no <a>waiting
              worker</a>, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
              name is "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Wait for the <a>installing worker</a> or <a>waiting worker</a> of
              <var>registration</var> to become its <a>active worker</a>.
              </li>
              <li>If <var>registration</var> fails to activate either worker, reject
              <var>promise</var> with a <code><a>DOMException</a></code> whose name is
              "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Once <var>registration</var> has an <a>active worker</a>, proceed with the steps
              below.
              </li>
            </ol>
          </li>
          <li>
            Let <var>paymentMethods</var> be a list of identifiers from <var>manifest</var> section
            on supported payment methods. Ensure that the payment app is licensed to claim support for the payment methods (e.g., they are explicitly authorized, or the payment method imposes no constraints). Otherwise, reject with a <code><a>DOMException</a></code> whose
            name is "<code><a>NotAllowedError</a></code>" and terminate these steps.
          </li>
          <li>
            Ask the user whether they allow the <a>payment app</a> to be
            registered to handle the indicated <a>payment methods</a>
            (unless a prearranged trust relationship applies or the user has
            already granted or denied permission explicitly for this <a>payment
            app</a>).
          </li>
          <li>
            If permission is not granted, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>NotAllowedError</a></code>" and terminate these steps.
          </li>
          <li>
            Register the <a>payment app</a> with the user agent for future use,
            associating <var>manifest</var>'s <code>name</code> and
            <code>icons</code> set with the payment app for user reference.
          </li>
          <li>
            For each <a>PaymentAppOption</a> present in the
            <code>options</code> field of the <var>manifest</var>:
            <ol>
              <li>
                Add a new payment option to the <a>payment app</a>'s
                registration, associating it with the <a>PaymentAppOption</a>
                <code>name</code> and <code>icons</code> fields.
              </li>
              <li>
                For each <a>payment method</a> indicated in the
                <a>PaymentAppOption</a>'s <code>enabledMethods</code>
                field, associate the payment option and the <a>payment app</a>
                with the payment method.
              </li>
            </ol>
          </li>
          <li>
            Resolve <em>promise</em> with <code>undefined</code>.
          </li>
        </ol>
      </section>
      <section id="get-manifest">
      <h3>
        PaymentAppManager.getManifest()
      </h3>
        <p>
            The <code><dfn>getManifest</dfn></code> method is used to
            retrieve the properties associated with a registered
            <a>payment app</a>.
        </p>
        <p>The <code>getManifest</code> method, when invoked, MUST run the
        following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            If there is no <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>, reject <var>promise</var> with a
            <a>DOMException</a> whose name is "<code><a>AbortError</a></code>"
            and terminate these steps.
          </li>
          <li>
            Retrieve the <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>.
          </li>
          <li>
            Let <var>manifest</var> be the retrieved <a>PaymentAppManifest</a>.
          </li>
          <li>
            Resolve <em>promise</em> with <var>manifest</var>.
          </li>
        </ol>
      </section>
  </section>
  <section id="payment-app-manifest">
  <h2>
    <a>PaymentAppManifest</a> interface
  </h2>
  <p class="issue"><a href="https://github.com/w3c/webpayments-payment-apps-api/issues/69">Issue 69</a>: The Payment Apps Task Force has a goal of alignment with the draft <a href="https://github.com/w3c/manifest">Web App Manifest</a> specification for data used to display payment app and options for selection by the user. More work is necessary to determine whether the Payment App API should reference (part of) the Web App Manifest specification, import definitions while that specification remains a draft, or define new terms.</p>
      <pre id="payment-app-manifest-idl" class="idl">
      dictionary AvailableOption {
        required DOMString id;
        short modifier;
      };

      callback CanHandleCallback = Sequence&lt;AvailableOption&gt;
      (sequence&lt;PaymentMethodData&gt; methodData, PaymentDetails details);

      dictionary PaymentAppManifest {
        required DOMString name;
        sequence&lt;ImageObject&gt; icons;
        required sequence&lt;PaymentAppOption&gt; options;
        CanHandleCallback canHandle;
      };
      </pre>
        <dl>
            <dt><code>name</code> member</dt>
            <dd>
                The <code>name</code> member is a string that represents the
                label for this <a>payment app</a> as it is usually displayed
                to the user.
            </dd>
            <dt><code>icons</code> member</dt>
            <dd>
                The <code>icons</code> member is an array of image objects that can serve as iconic representations of the <a>payment app</a> when presented to the user for selection.
            </dd>
            <dt><code>options</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-manifest-options"><code>options</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option.
            </dd>
            <dd class="issue">
                <p>Options are an extra layer of abstraction, because they allow
                  flattening of payment apps. The flattening may result in unique
                  UX challenges. For example, if two payment apps both have
                  "<em>Visa ending in ***4756</em>" payment option, then users may
                  be confused when they see two such labels in UI. One solution
                  is to prepend the payment app name, e.g., "<em>ExampleApp Visa
                  ending in ***4756</em>". However, when only one app is
                  installed, the text "<em>ExampleApp</em>" is redundant.</p>
            </dd>
            <dt><code>canHandle</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-manifest-canhandle"><code>canHandle</code></dfn>
                member indicates a function that is responsible for determining
                whether the <a>payment app</a> being registered is capable of
                handling a given request. If this member is not included in the
                manifest, the payment app is expected to be capable of
                handling all requests for the indicated <a>payment method
                identifiers</a>. <a>canHandle</a> runs with a globally unique
                origin, and is not allowed network access. The return value from
                <a>canHandle</a> is a sequence of zero or more
                <code>HandledOptions</code> dictionaries. Each dictionary
                represents a <code>PaymentAppOption</code> that can handle
                the request. The mandatory <code>AvailableOption.id</code>
                member corresponds to the <code>PaymentAppOption.id</code> for
                the <code>PaymentOption</code> corresponding to the dictionary.
                If present, the <code>AvailableOption.modifier</code> member is
                an index into the <code>PaymentRequest.modifiers</code>
                sequence, indicating which modifer applies to the corresponding
                <code>PaymentAppOption</code>.
            </dd>
        </dl>
  </section>
  <section id="payment-app-options">
  <h2>
    <a>PaymentAppOption</a> dictionary
  </h2>
      <pre id="payment-app-options-idl" class="idl">
      dictionary PaymentAppOption {
        required DOMString name;
        sequence&lt;ImageObjects&gt; icons;
        required DOMString id;
        sequence&lt;DOMString&gt; enabledMethods;
      };
      </pre>
      <dl>
	<dt><code>name</code> member</dt>
        <dd>
          The <code>name</code> member is a string that represents the
                label for this <a>payment app</a> as it is usually displayed
                to the user.
            </dd>
            <dt><code>icons</code> member</dt>
            <dd>
                The <code>icons</code> member is an array of image objects that can serve as iconic representations of the <a>payment app</a> when presented to the user for selection.
            </dd>

            <dt><code>id</code> member</dt>
            <dd>
                The <code>id</code> member is an identifier, unique
                within the <a>PaymentAppManifest</a>, that will be passed to the
                payment app to indicate the <a>PaymentAppOption</a> selected
                by the user.
            </dd>
            <dt><code>enabledMethods</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-option-enabled-methods"><code>enabledMethods</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option. See also the <a>canHandl</a> function, which enables payment app developers to specify in finer granularity the conditions under which the payment app supports a payment method.
            </dd>
        </dl>
  </section>
  <section id="register-example">
  <h3>
    Registration Example
  </h3>
    <p>The following example shows how to register a <a>user agent-based payment
    app</a>:</p>
       <pre class="example highlight" title="Payment App Registration">
         navigator.serviceWorker.register('/exampleapp.js')
         .then(function(registration) {
           return registration.paymentAppManager.setManifest({
             name: "ExampleApp",
             icons: [
                {
                  "src": "icon/lowres.webp",
                  "sizes": "48x48",
                  "type": "image/webp"
                },{
                  "src": "icon/lowres",
                  "sizes": "48x48"
                } ]
             options: [
               {
                 name: "Visa ending ****4756",
                 id: "dc2de27a-ca5e-4fbd-883e-b6ded6c69d4f",
                 enabledMethods: ["basic-card"]
               },
               {
                 name: "My Bob Pay Account: john@example.com",
                 id: "c8126178-3bba-4d09-8f00-0771bcfd3b11",
                 enabledMethods: ["https://bobpay.com/"]
               },
               {
                 name: "Add new credit/debit card to ExampleApp",
                 id: "new-card",
                 enabledMethods: ["basic-card"]
               }
             ],
             canHandle: function (methodData, details) {
               // TODO: Code here to return mapping from payment option IDs
               // to methodData option indices.
             }
           });
         }).then(function() {
           console.log("Installed payment app from /paymentapp.js"); // Success!
         }).catch(function(error) {
           console.log(error);
         });
     </pre>
     <p class="issue" title="Payment method identifiers">
       The Editors will update the payment method identifier syntax in this
       and other examples to align with [[!METHOD-IDENTIFIERS]], once a final
       format has been agreed upon.
     </p>
  </section>

</section>
<section id="matching">
  <h2>Payment App Matching</h2>

  <p>
    When the <a>mediator</a> calculates <i>acceptedMethods</i> during the
    process of running the steps for the <code>PaymentRequest.show()</code>
    method, the means of determining whether a registered <a>payment app</a>
    should be made available for user selection is computed by
    performing the following steps:
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Set <var>requestMethods</var> to a set containing the values
          in the <code>supportedMethods</code> value of the
          <code>PaymentMethodData</code> from the <code>PaymentRequest</code>
          on which <code>show()</code> has been called.
        </li>
        <li>
          For each <var>paymentDetailsModifier</var> in
          <code>details.modifiers</code> in the
          <code>PaymentDetails</code> from the <code>PaymentRequest</code>
          on which <code>show()</code> has been called, add all entries in
          <var>paymentDteailsModifier</var>.<code>supportedMethods</code> to
          <var>requestMethods</var>.
        </li>
        <li>
          Set <var>commonMethods</var> to the set union of
          <var>paymentMethods</var> and <var>requestMethods</var>.
        </li>
        <li>
          If <var>commonMethods</var> is a null set, this <a>payment app</a> is
          not considered to be a candidate to handle the
          <code>PaymentRequest</code> and terminate these steps.
        </li>
        <li>
          If the <code>PaymentAppManifest</code> does not contain a
          <code>canHandle</code> attribute, then this <a>payment app</a> is a
          candidate for handling the <code>PaymentRequest</code>. Only those
          <a>PaymentAppOption</a>s that have <code>enabledMethods</code>
          containing at least one member of <var>commonMethods</var> are to be
          displayed to the user. Terminate these steps.
        </li>
        <li>
          Set <var>methodDataCopy</var> to a deep copy of the
          <code>methodData</code> parameter of the <code>PaymentRequest</code>.
        </li>
        <li>
          Set <var>detailsCopy</var> to a deep copy of the
          <code>details</code> parameter of the <code>PaymentRequest</code>.
        </li>
        <li>
          Create an isolated interpreted context, a JavaScript realm that
          operates with a globally unique origin. Access to the network must be
          disallowed from within this context.
        </li>
        <li>
          Populate the realm with a single global function,
          <var>canHandle</var>, set to the value of
          <code>PaymentAppManifest.canHandle</code>.
        </li>
        <li>
          Execute <var>canHandle</var> in the realm, passing
          <var>methodDataCopy</var> and <var>detailsCopy</var> as the parameters
          to the function. Set <var>returnValue</var> to the return value of
          the function.
        </li>
        <li>
          If the execution of <var>canHandle</var> results in an exception or
          <var>returnValue</var> is not a <code>Sequence</code> of
          <code>AvailableOption</code>s, then this
          <a>payment app</a> is not considered to be a candidate to handle the
          <code>PaymentRequest</code>. Terminate these steps.
        </li>
        <li>
          For each <code>AvailableOption</code> of <var>returnValue</var>,
          verify that the value of its <code>modifier</code> entry, if
          present, is an integer, no smaller than 0, and no larger than the
          largest index of <code>PaymentRequest.modifiers</code> sequence. Any
          <code>AvailableOption</code> that fails this validation is removed
          from the sequence.
        </li>
        <li>
          If <var>returnValue</var> has no remaining
          <code>AvailableOption</code>s, then this
          <a>payment app</a> is not considered to be a candidate to handle the
          <code>PaymentRequest</code>. Terminate these steps.
        </li>
        <li>
          If processing has reached this point, then the <a>payment app</a> is
          a candidate for processing the <code>PaymentRequest</code>. Each
          <code>AvailableOption</code>
          in <var>returnValue</var> corresponds to a matching
          <code>PaymentAppOption</code> that can service the request. If present
          the <code>PaymentAppOption.modifier</code> indicates which
          <code>PaymentDetailsModifier</code> will be applied by the
          corresponding <code>PaymentAppOption</code>.
        </li>
      </ol>
  </p>
</section>
<section id="selection">
  <h2>Payment App Selection</h2>
  <section>
    <h3>Selectable App Information Display</h3>
    <p>
      The output of the payment method matching algorithm will be a list of matching payment apps and options from registered
      payment apps, and a list of recommended payment apps. The user agent presents this list of <a>displayed payment apps</a> to the user for selection. The user agent  <span class='rfc2119'>MUST</span> enable the user to select any displayed payment app.
    </p>
  </section>
  <section>
    <h3>Matching Payment Apps</h3>
    <ul>
      <li>The user agent <span class='rfc2119'>MUST</span> enable the user to select any matching payment app. <strong>Note:</strong> See the definition of matching payment app, which excludes payment apps ignored due to user configuration or security issues. Note also that the language here is about enabling selection rather than display &mdash; when the user agent displays only a subset of matching payment apps (e.g., the most recently used), the user must still be able to access other matching payment apps. </li>
      <li>The user agent <span class='rfc2119'>MUST</span> enable the user to select any matching <a href="#payment-app-options">payment app options</a>.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> favor user-side order preferences (based on user configuration or behavior) over payee-side order preferences.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> display matching payment apps in an order that corresponds to the order of supported payment methods provided by the payee, except where overridden by user-side order preferences.</li>
      <li>The user agent <span class='rfc2119'>SHOULD</span> allow the user to configure the display of matching payment apps to control the ordering and define preselected defaults.</li>
    </ul>
  </section>
  <section>
    <h3>Recommended Payment Apps</h3>
    <div class="issue">What is the means by which the payee provides information about recommended payment apps in the call to payment request API? See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/79">issue 79</a>.</div>
    <ul>
      <li>The user agent <span class='rfc2119'>SHOULD</span> display recommended payment apps and allow configuration to not display recommended payment apps.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> distinguish unregistered recommended payment apps from registered payment apps.</li>
      <li>The user agent <span class='rfc2119'>SHOULD</span> display any recommended apps in the order specified by the payee.</li>
    </ul>
  </section>
  <section>
    <h3>User Experience Considerations</h3>
    <div class="issue" title="Payment app selection user experience consistency">
      <p>We have identified a number of <a href="https://github.com/w3c/webpayments/wiki/PaymentApp_Notes#user-experience-descriptions">user experiences</a> that we would like to harmonize. Just a few examples here:</p>
      <ol>
        <li>User has no registered payment apps.</li>
        <li>User has apps with supported but no enabled payment methods.</li>
        <li>User has apps with supported and enabled payment methods.</li>
        <li>Merchant wishes to recommend a payment app to the user.</li>
        <li>User agent wishes to recommend a payment app that supports a payment method for which the user does not
          currently have a supporting payment app.</li>
      </ol>
    </div>
    
    <p>The following are examples of user agent ordering of selectable payment apps.</p>
    <ul>
      <li>For a given Web site, display payment apps in an order that reflects usage patterns for the site (e.g., a frequently used payment app at the top, or the most recently used payment app at the top).</li>
      <li>Enable the user to set a preferred order for a given site or for all sites.</li>
      <li>Display a payment app that is both registered by the user
	and recommended at the top of a list.</li>
      <li>Display a payment app that is both registered by the user
	and corresponds to the origin of the site being visited at the top of a list.</li>
    </ul>
  </section>
</section>
<section id="invocation">
  <h2>Payment App Invocation, Display and Response</h2>
  <p>
      Once the user has selected a payment app, the user agent is
      responsible for preparing a <a>payment app request</a>, invoking the
      payment app, providing the request data to the payment app, and
      returning the payment app response through the Payment Request API.
  </p>
  <section id="sec-app-request">
    <h3>Payment App Request</h3>
    The <a>payment app request</a> is conveyed using the following
    dictionary:
    <pre class="idl">
      dictionary PaymentAppRequest {
        DOMString origin;
        sequence&lt;PaymentMethodData&gt; methodData;
        PaymentItem total;
        sequence&lt;PaymentDetailsModifier&gt; modifiers;
        DOMString optionId;
      };
    </pre>
    <dl>
      <dt><code>origin</code> attribute</dt>
      <dd>
        This attribute a string that indicates the <a>origin</a> of the
        <a>payee</a> web page. It MUST be formatted according to the
        "<a href="https://tools.ietf.org/html/rfc6454#section-6.1">Unicode
        Serialization of an Origin</a>" algorithm defined in section 6.1 of
        [[!RFC6454]].
      </dd>
      <dt><code>methodData</code> attribute</dt>
      <dd>
        This attribute contains <code>PaymentMethodData</code>
        dictionaries containing the <a>payment method identifiers</a> for the
        <a>payment methods</a> that the web site accepts and any associated
        <a>payment method</a> specific data.
        It is populated from the
        <a>PaymentRequest</a> using the <a>Method Data Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>total</code> attribute</dt>
      <dd>
        This attribute indicates the total amount being requested for payment.
        It is initialized with a <a>structured clone</a> of the
        <code>total</code> field of the <code>PaymentDetails</code> provided
        when the corresponding <a>PaymentRequest</a> object was instantiated.
      </dd>
      <dd class="issue">Is the specification missing the top level "displayItems"?
      </dd>
      <dd class="issue">Keep an eye on <a href="https://github.com/w3c/browser-payment-api/issues/287">issue 287</a>. If the user agent generates a transaction ID, that ID must be passed to the payment app. If the merchant provides the transaction ID, that ID is already available through methodData.
      </dd>
      <dt><code>modifiers</code> attribute</dt>
      <dd>
        This sequence of <code>PaymentDetailsModifier</code> dictionaries
        contains modifiers for particular payment method identifiers (e.g.,
        if the payment amount or currency type varies based on a
        per-payment-method basis).  It is populated from the
        <a>PaymentRequest</a> using the <a>Modifiers Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>optionId</code> attribute</dt>
      <dd>
        This attribute indicates the <a>PaymentAppOption</a> selected by
        the user. It corresponds to the <code>id</code> field provided during
        payment app registration.
      </dd>
    </dl>
    <section>
      <h3>
        <dfn>Method Data Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>methodData</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>dataList</var> to the newly created <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\methodData]]</var> in the
          corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inData</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inData</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentMethodData</code> object.
            </li>
            <li>
              Set <var>outData</var> to the newly created
              <code>PaymentMethodData</code>.
            </li>
            <li>
              Set <var>outData</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outData</var>.data to a <a>structured clone</a> of
              <var>inData</var>.<code>data</code>.
            </li>
            <li>
              Append <var>outData</var> to <var>dataList</var>.
            </li>
          </ol>
          <li>
            Set <code>methodData</code> to <var>dataList</var>.
          </li>
      </ol>
    </section>
    <section>
      <h3>
        <dfn>Modifiers Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>modifiers</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>modifierList</var> to the newly created
          <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\paymentDetails]]</var>.<code>modifiers</code>
          in the corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inModifier</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inModifier</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentDetailsModifier</code> object.
            </li>
            <li>
              Set <var>outModifier</var> to the newly created
              <code>PaymentDetailsModifier</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>total</code> to a <a>structured
              clone</a> of <var>inModifier</var>.<code>total</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>additionalDisplayItems</code>
              to a <a>structured clone</a> of
              <var>inModifier</var>.<code>additionalDisplayItems</code>.
            </li>
            <li>
              Append <var>outModifier</var> to <var>modifierList</var>.
            </li>
          </ol>
          <li>
            Set <code>modifiers</code> to <var>modifierList</var>.
          </li>
      </ol>
    </section>
  </section>
  <section id="sec-app-response">
    <h3>Payment App Response</h3>
    The <a>payment app response</a> is conveyed using the following
    dictionary:
    <pre class="idl">
      dictionary PaymentAppResponse {
        DOMString methodName;
        object details;
      };
    </pre>
    <dt><code>methodName</code> attribute</dt>
    <dd>
      The <a>payment method identifier</a> for the <a>payment method</a>
      that the user selected to fulfil the transaction.
    </dd>
    <dt><code>details</code> attribute</dt>
    <dd>
      A <a>JSON-serializable object</a> that provides a <a> payment
      method</a> specific message used by the merchant to process the
      transaction and determine successful fund transfer.
    </dd>
  </section>
  <section>
    <h3>Payment App Invocation</h3>
    <p>
      <a>Payment apps</a> are invoked when a <a>payee</a> requests a payment
      by calling <code>PaymentRequest.show()</code> and the user selects a
      payment app (or has one implicitly selected by previously established
      user preferences). If the user selects a <a>user agent-based payment
      app</a> to service the request, the <a>service worker</a> corresponding
      to that application receives an event with the
      <a>PaymentAppRequest</a> containing information about the payment
      being requested. The event also contains a function that allows the
      payment app to provide a <a>payment response</a> back to the
      <a>payee</a>. This process is formally described in the following
      sections.
    </p>
    <section>
    <h3>
      Extension to <code>ServiceWorkerGlobalScope</code>
    </h3>
      <p>
        The Service Worker specification defines a
        <code>ServiceWorkerGlobalScope</code> interface [[!SERVICE-WORKERS]],
        which this specification extends.
      </p>
      <pre class="idl">
        partial interface ServiceWorkerGlobalScope {
          attribute EventHandler onpaymentrequest;
        };
      </pre>
      <dl>
        <dt><code>onpaymentrequest</code> attribute</dt>
        <dd>
          The <code>onpaymentrequest</code> attribute is an <a>event handler</a>
          whose corresponding <a>event handler event type</a> is
          <code>paymentrequest</code>.
        </dd>
      </dl>

      <p>The <a>PaymentRequestEvent</a> interface represents a received
      <a>payment request</a>.
    </section>
    <section>
    <h3>
      The <code>paymentrequest</code> Event
    </h3>
      <p>
        The <a>PaymentRequestEvent</a> represents a received <a>payment
        request</a>.
      </p>
      <pre class="idl">
      [Exposed=ServiceWorker]
      interface PaymentRequestEvent : ExtendableEvent {
        readonly attribute PaymentAppRequest appRequest;
        void respondWith(<a>Promise</a>&lt;<a>PaymentAppResponse</a>&gt;appResponse);
      };
      </pre>
      <dl>
        <dt><code>appRequest</code> attribute</dt>
        <dd>
          This attribute contains the <a>payment app request</a> associated
          with this <a>payment request</a>.
        </dd>
        <dt><code>respondWith</code> method</dt>
        <dd>
          This method is used by the payment app to provide a
          <a>PaymentAppResponse</a> when the payment successfully completes.
        </dd>
      </dl>
        <p>
          Upon receiving a <a>payment request</a> by way of
          <code>PaymentRequest.show()</code> and subsequent user selection of a
          <a>user agent-based payment app</a>, the <a>user agent</a> MUST run
          the following steps or their equivalent:
        </p>
        <ol>
          <li>Let <var>registration</var> be the <a>service worker
          registration</a> corresponding to the <a>user agent-based payment app</a>
          selected by the user.
          </li>
          <li>If <var>registration</var> is not found and the selected app
            is a <a>recommended app</a>, register the service worker as described
            in <a href="#h-registration"></a>, skipping user consent and user
            agent registration for future use in <a href="#h-set-manifest"></a> (steps 9-11).
          </li>
          <li>If <var>registration</var> is not found, reject the Promise that
            was created by <code>PaymentRequest.show()</code> with a
            <a>DOMException</a> whose value "<a>InvalidStateError</a>" and
            terminate these steps.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with a
          <a>service worker registration</a> of <var>registration</var> and
          <var>callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object that was provided
                  as an argument.  </li>
              <li>Create a <a>trusted event</a>,
                  <var>e</var>, that uses the
                  <code><a>PaymentRequestEvent</a></code> interface, with the
                  event type <code>paymentrequest</code>, which does not bubble,
                  cannot be canceled, and has no default action.  </li>
              <li>Set the <code>appRequest</code> attribute of
                  <var>e</var> to a new <a>PaymentAppRequest</a> instance,
                  populated as described in
                  <a href="#sec-app-request"></a>.
              </li>
              <li>Dispatch <var>e</var> to <var>global</var>.</li>
              <li>Wait for all of the promises in the <a>extend lifetime
                  promises</a> of <var>e</var> to resolve.</li>
              <li>If the <a>payment app</a> has not provided a <a>payment app
                  response</a> as described in <a
                  href="#sec-payment-app-response"></a>, reject the Promise that
                  was created by <code>PaymentRequest.show()</code> with a
                  <a>DOMException</a> whose value "<a>OperationError</a>".
            </ol>
          </li>
        </ol>
    </section>
  </section>
  <section>
  <h3>
    Payment App Display
  </h3>
  <p>An invoked payment app may or may not choose to display information or request user input. For example:</p>
  <ul>
    <li>A payment app might always open a window so that the user can provide an authorization code.</li>
    <li>A payment app may open a window when first selected to pay during a session, but for subsequent payments in the same session, it might (through configuration) perform its duties without opening a window or requiring user interaction.</li>
    <li>The browser might support user configuration to streamline payments, such as "always use this payment app on this Web site" or "when there is just one matching payment app launch it automatically." Automatically invoked payment apps may wish to open windows without a recent explicit user action.</li>
    <li>A payment app that merely returns data might never need to open a window.</li>
  </ul>
  <p>To support scenarios that involve visual display and user interaction, user agents MUST allow payment apps to call the <code>clients.openWindow()</code> method defined in [[!SERVICE-WORKERS]].</p>
  <p>[[!SERVICE-WORKERS]] expects a user interaction to have occurred in order to open a Window. This user interaction is obvious when the user explicitly selects a payment app to make a payment. However, when user agent or payment app configuration allows payment app invocation without explicit user selection, the user agent MUST consider the <a>paymentrequest</a> event as the relevant user interaction for a <code>clients.openWindow()</code> request. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/73">issue 73</a> for more discussion.</p>

  <p class="note">Implementations may vary on how windows open.
      For example, while opening an entirely new window is possible,
      it is more likely that the contents will be rendered in a way that makes
      it more obvious that the interactions pertain to the payment
      transaction. The opening of a <a>payment app window</a> versus
      other types of windows can be distinguished based on the event type the
      user agent is using to grant permission to open a window.
  </p>
  <div class="note">
    <p><em>The remainder of this section is currently a non-normative explanation of how
    the service worker <code>WindowClient</code> class can be used to interact
    with users.</em></p>
    <p>
      Upon calling clients.openWindow(), the payment app receives a
      <a>Promise</a> which resolves to a <code>WindowClient</code>. For the
      purposes of this discussion, we will refer to this
      <code>WindowClient</code> as <var>client</var>.  The payment app can use
      the <var>client</var>.<code>postMessage()</code> method to send messages
      to the <a>payment app window</a>.
    </p>
    <p>
      When a <a>payment app window</a> receives the <code>message</code> event
      from the payment app, this event will contain a <code>source</code>
      attribute which indicates the payment app's service worker. The payment
      app window can then call <code>source.postMessage()</code> to send a
      response to the payment app. Once the payment app window has complete its
      interaction with the user, it closes the window and uses this
      <code>postMessage()</code> call to return information to the payment app.
    </p>
    <p class="issue">
      In order for this approach to work, we have to treat a
      <a>paymentrequest</a> as permission to open a popup, which is a formal
      property relied up on by [[!SERVICE-WORKERS]]. We need to be careful
      that this does not become an end-run around exiting pop-up protections.
    </p>
    <p class="issue">
      Do we want to define a new <code>FrameType</code> for <a>payment app
      window</a>s? This requires input from someone with detailed knowledge of
      service worker design.
    </p>
    </div>
  </section>
  <section id="sec-payment-app-response">
    <h3>Payment App Response</h3>
    <p>
      The user agent receives a successful response from the payment app
      through resolution of the Promise provided to the <code>respondWith</code>
      function of the corresponding <a>PaymentRequestEvent</a> dictionary.
      The application is expected to resolve the Promise with a
      <code>PaymentAppResponse</code> instance containing the
      payment response. In case of user cancellation or error, the
      application may signal failure by rejecting the Promise.
    </p>
    <p>
      If the Promise is rejected, the user agent MUST run the <dfn>payment app
      failure algorithm</dfn>. The exact details of this algorithm is left for
      user agent implementers to decide on. Acceptable behaviors include,
      but are not limited to:
    </p>
    <ul>
      <li>
        Letting the user try again, with the same payment app or with a
        different one.
      </li>
      <li>
        Rejecting the Promise that was created by
        <code>PaymentRequest.show()</code>.
      </li>
    </ul>
    <p>
      If this Promise is successfully resolved, the user agent MUST run the
      <a>user accepts the payment request algorithm</a> as defined in
      [[!PAYMENT-REQUEST-API]], replacing steps 6 and 7 with these steps or
      their equivalent:
    </p>
    <ol>
      <li>
        Set <var>appResponse</var> to the <code>PaymentAppResponse</code>
        instance used to resolve the
        <a>PaymentRequestEvent</a><code>.respondWith</code> Promise.
      </li>
      <li>
        If <var>appResponse</var>.<code>methodName</code> is not present or
        not set to one of the values from
        <a>PaymentRequestEvent</a>.<code>appRequest</code>, run the <a>payment app
        failure algorithm</a> and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>methodName</code>
        and assign it to
        <var>response</var>.<code>methodName</code>.
      </li>
      <li>
        If <var>appResponse</var>.<code>details</code> is not present, run the
        <a>payment app failure algorithm</a> and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>details</code>
        and assign it to
        <var>response</var>.<code>details</code>.
      </li>
    </ol>

    <p>The following example shows how to respond to a payment request:</p>
    <pre class="example highlight" title="Sending a Payment Response">
      paymentRequestEvent.respondWith(new Promise(function(accept,reject) {
        /* ... processing may occur here ... */
        accept({
          methodName: "basic-card#visa",
          details: {
            card_number :  "1232343451234",
            expiry_month : "12",
            expiry_year :  "2020",
            cvv :          "123"
           }
        });
      });
    </pre>

    <p class="note">
      [[!PAYMENT-REQUEST-API]] defines a <code>paymentRequestID</code>
	that parties in the ecosystem (including payment app providers
	and payees) may use for reconciliation after network or other
	failures.</p>
  </section>
  <section id="post-example">
  <h3>Example using HTTP POST</h3>
    <p>
      This example codes shows how to use this API via a scheme in
      which a <code>POST</code> is sent to a URL with the payment request as a
      body. The response is allowed to be either <code>application/json</code>
      (which is inferred to contain a payment response), or
      <code>text/html</code> (which contains content to be rendered to the
      user).
    </p>
    <pre class="example highlight" title="Simple POST-based Payment App"
    id="example-post-payment-app">
      var contentType;
      var paymentPromise;
      /* Handle payment request from a payee */
      self.addEventListener('paymentrequest', function(e) {
        paymentPromise = new Promise(function(accept, reject) {
          fetch("https://www.example.com/bobpay/process",
            { method: "POST",  body: JSON.stringify(e.data) })
          .then(function(response) {
            contentType = response.headers.get("content-type");
            if (!contentType) {
              throw new Error("No content type header");
            }
            return response.text();
          }).then(function(body) {
            if(contentType.indexOf("application/json") !== -1) {
              /* Respond to the payment request with the received body */
              accept(JSON.parse(body));
            } else if (contentType.indexOf("text/html") !== -1) { {
              /* Open a new payment window and populate it with the
                 document returned from the response */
              var url = "data:text/html;base64," + btoa(body);
              clients.openWindow(url).then(function(windowClient) {
                windowClient.postMessage(e.data);
              });
            } else {
              throw new Error("Unexpected value in content type header");
            }
          }).catch(function(err) {
            reject(err);
          });
        e.respondWith(paymentPromise);
      });

      /* Handle payment response from a payment app window */
      self.addEventListener('message', function(e) {
        if (e.data.hasOwnProperty('name')) {
          paymentPromise.reject(e.data);
        } else {
          paymentPromise.resolve(e.data);
        }
      });
    </pre>
    <p>Using the simple scheme described above, a trivial HTML page that is
    loaded into the <a>payment app window</a> to implement the <em>basic
    card</em> scheme might look like the following:</p>
    <pre class="example highlight" title="Simple Payment App Window">
&lt;html&gt; &lt;body&gt; &lt;form id="form"&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Card Number:&lt;/th&gt;&lt;td&gt;&lt;input name="card_number"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Month:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_month"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Year:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_year"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;CVV:&lt;/th&gt;&lt;td&gt;&lt;input name="cvv"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="submit" value="Pay"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;script&gt;
window.addEventListener("message", function(e) {
  var form = document.getElementById("form");
  /* Note: message sent from payment app is available in e.data */
  form.onsubmit = function() {
    var details = {};
    ["card_number","expiry_month","expiry_year","cvv"].forEach(function(field) {
      details[field] = form.elements[field].value;
    });
    e.source.postMessage({
      methodName: "basic-card#visa",
      details: details
    });
    window.close();
  }
});
&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
    </pre>

  </section>

</section>
<section id="security">
  <h2>Security and Privacy Considerations</h2>
  <section>
    <h3>Design Considerations</h3>
    <ul>
      <li>The API does not share information about the user's registered payment methods or payment apps with the payee. The only information that is shared is the result of user selection.</li>
    </ul>
  </section>
  <section>
    <h3>Secure Communications</h3>
    <ul>
      <li>See <a href="https://www.w3.org/TR/service-workers/#security-considerations">Service Worker security considerations</a></li>
      <li>Payment method security is outside the scope of this specification and is addressed by payment apps that support those payment methods.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Authenticity</h3>
    <ul>
      <li>To avoid problems such as phishing-type attacks on payee sites, we want to be able to ensure the authenticity of payment apps. In general we expect to rely on origin information for establishing payment app authenticity. In contexts where payment apps are referenced other than on their origin, we are considering additional measures to help establish authenticity. Examples: validate a digital signature prior to launching a recommended app or a registered payment app without associated origin information.</li>
      <li><span class="note">Note: More work is required on good practice so that it is easy for users to use trusted apps (e.g., white listing by the browser or merchant) and hard to use risky apps (e.g., warnings to the user and explicit user overrides as done today with untrusted certificates).</span></li>
    </ul>
  </section>
  <section>
    <h3>Data Validation</h3>
    <ul>
      <li>Payees should validate that the data they have received through the paymentRequest API is what they expect (e.g., the total that was paid, etc.).</li>
    </ul>
  </section>
  <section>
    <h3>Private Browsing Mode</h3>
    <ul>
      <li>When the Payment Request API is invoked in a "private browsing mode," the user agent should launch user agent-based payment apps in a private context. This will generally prevent sites from accessing any previously-stored information. In turn, this is likely to require either that the user log in to the payment app or re-enter payment instrument details.</li>
    </ul>
  </section>
</section>
</body>
</html>
