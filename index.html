<!DOCTYPE html>
<html>
<head>
  <title>Payment App API</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='utils.js' class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            shortName:  "payment-apps",
            edDraftURI:   "https://w3c.github.io/webpayments-payment-apps-api/",
            specStatus: "ED",
            editors: [
                {   name:       "Adrian Hope-Bailie",
                    url:        "https://github.com/adrianhopebailie",
                    company:    "Ripple",
                    companyURL: "https://ripple.com"
                },
                {   name:       "Tommy Thorsen",
                    url:        "https://github.com/tommythorsen",
                    company:    "Opera",
                    companyURL: "https://opera.com"
                },
                {   name:       "Adam Roach",
                    url:        "https://github.com/adamroach",
                    company:    "Mozilla",
                    companyURL: "https://mozilla.org"
                },
                {   name:       "Jason Normore",
                    url:        "https://github.com/jnormore",
                    company:    "Shopify",
                    companyURL: "https://shopify.com"
                },
                {   name:       "Ian Jacobs",
                    url:        "http://www.w3.org/People/Jacobs/",
                    company:    "W3C",
                    companyURL: "https://www.w3.org/"
                },
            ],

            useExperimentalStyles: true,
            license:      "w3c-software-doc",

            wg:           "Web Payments Working Group",
            wgURI:        "https://www.w3.org/Payments/WG/",
            wgPublicList: "public-payments-wg",
            wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83744/status",

            issueBase:    "https://github.com/w3c/webpayments-payment-apps-api/issues/",

            localBiblio:  {
                "PAYMENT-REQUEST-API": {
                    title:    "Payment Request API",
                    href:     "http://www.w3.org/TR/payment-request/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurray"
                    ],
                    status:   "FPWD"
                },
                "METHOD-IDENTIFIERS": {
                    title:    "Payment Method Identifiers",
                    href:     "https://www.w3.org/TR/payment-method-id/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurry"
                    ],
                    status:   "FPWD"
                }
            }
        };
    </script>
    <style>
        dt { margin-top: 0.75em; }
        table { margin-top: 0.75em; border-collapse:collapse; border-style:hidden hidden none hidden }
        table thead { border-bottom:solid }
        table tbody th:first-child { border-left:solid }
        table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
        li { margin-top: 0.5em; margin-bottom: 0.5em;}
    </style>
</head>
<body>
<section id='abstract'>
  <p>The Payment Request API [[!PAYMENT-REQUEST-API]] provides
    a standard way to initiate payment requests from Web pages and
    applications. User agents implementing that API prompt the user
    to select a way to handle the payment request, after which
    the user agent returns a payment response to the originating site.
    This specification adds <strong>payment apps</strong>
    to that user experience. It defines how users
    register payment apps with user agents, how user agents support the display of
    information about payment options the user can select to handle the
    payment request, how the user selects a payment app, and how communication takes
    place between user agents and payment apps to fulfill the requirements of the
    underlying Payment Request API.</p>
</section>
<section id='sotd'>
    <p>The Web Payments Working Group maintains <a href="https://github.com/w3c/webpayments-payment-apps-api/issues">
        a list of all bug reports that the group has not yet addressed</a>.
        This draft highlights some of the pending issues that are still to
        be discussed in the working group. No decision has been taken on
        the outcome of these issues including whether they are valid. Pull
        requests with proposed specification text for outstanding issues
        are strongly encouraged.</p>
</section>
<section class='informative'>
  <h2>Introduction</h2>

  <p>The Web Payments Working Group seeks to streamline payments on the Web to
  help reduce payment "abandonment" and make it easier to use
  new payment methods on the Web. It has published the Payment Request
  API [[!PAYMENT-REQUEST-API]] as a standard way to initiate payment
  requests from Web pages and applications. This specification adds
    payment apps to that user experience. A payment app is software that
    enables the user to fulfill a payment request using the user's
    preferred payment method.</p>

    <p>This specification defines:</p>
    <ul>
      <li>How users register and unregister payment apps with the user agent.</li>
      <li>How the user agent matches payment methods supported by the payee with those enabled in registered payment apps.</li>
      <li>How the user agent displays information about payment options to the user for selection.</li>
      <li>How the user agent invokes a payment app, communicates input/response data with it, and returns the response data to the underlying Payment Request API.</li>
    </ul>
  <p>Payment apps may be implemented in a variety of ways: as Web applications, native operating system applications,
      browser extensions, built-in user agent components, interface-less Web services, or a combination.
      This specification does not cover every aspect of communication on every platform.</p>
  <p class="note" title="User agent as payment request mediator">The Web Payments Working Group has used the term
      "mediator" to refer to the software (here, the user agent) that carries out the activities defined in this
      specification (matching, information display, etc.).</p>
</section>
<section id='conformance'>
    <p>
        This specification defines one class of products:
    </p>
    <dl>
        <dt><dfn>Conforming user agent</dfn></dt>
        <dd>
            <p>
                A <a>user agent</a> MUST behave as described in this specification
                in order to be considered conformant. In this specification, <a>user agent</a> means a <em>Web
                browser or other interactive user agent</em> as defined in [[!HTML5]].
            </p>
            <p>
                User agents MAY implement algorithms given in this
                specification in any way desired, so long as the end result is
                indistinguishable from the result that would be obtained by the
                specification's algorithms.
            </p>
            <p>
                A conforming Payment App API user agent MUST also be a
                <em>conforming implementation</em> of the IDL fragments
                of this specification, as described in the
                “Web IDL” specification. [[!WEBIDL]]
            </p>

            <aside class="note">
                This specification uses both the terms "conforming user agent(s)"
                and "user agent(s)" to refer to this product class.
            </aside>
        </dd>
    </dl>
</section>
<section id="dependencies">
  <h3>Dependencies</h3>
  <p>This specification relies on several other underlying specifications.</p>
    <dl>
        <!--
          <dt>Payment Request Architecture</dt>
          <dd>The term <dfn data-lt="payment method|payment methods">Payment Method</dfn>
	    is defined by the Payment Request Architecture document
        [[PAYMENT-ARCH]].</dd>
        -->
        <dt>Payment Request API</dt>
        <dd>The terms
            <dfn>PaymentRequest</dfn>, <dfn>PaymentResponse</dfn>,
            and
            <dfn>user accepts the payment request algorithm</dfn>
            are defined by the
            Payment Request API specification [[!PAYMENT-REQUEST-API]].</dd>
        <!--
        <dt>Payment Method Identifiers</dt>
        <dd>The terms <dfn data-lt="payment method|payment methods">payment method</dfn> and
            <dfn data-lt="payment method identifier|payment method identifiers">payment
            method identifier</dfn> are defined by the Payment Method
            Identifiers specification [[!METHOD-IDENTIFIERS]].</dd>
        -->
        <dt>HTML5</dt>
        <dd>The terms <dfn>global object</dfn>,<dfn>origin</dfn>, <dfn>queue a task</dfn>,
            <dfn>browsing context</dfn>, <dfn>top-level browsing
                context</dfn>, <dfn>structured clone</dfn>, 
                <dfn>event handler</dfn>, <dfn>event handler event type</dfn>,
                <dfn>trusted event</dfn>,
                and <dfn>current settings object</dfn> are defined by
                [[!HTML5]].</dd>
            <dt>ECMA-262 6th Edition, The ECMAScript 2015 Language
                Specification</dt>
            <dd>The term <dfn>Promise</dfn>

        <!--
            , <dfn>internal slot</dfn>,
                <dfn><code>TypeError</code></dfn>, <dfn>JSON.stringify</dfn>,
                <dfn>JSON.parse</dfn>, <dfn><code>Array</code></dfn>,
                <dfn><code>type</code></dfn> and the <dfn>[[\GetOwnProperty]]</dfn>
                operation are
        -->
                is defined by [[!ECMA-262-2015]].
        <!--
                <p>This document uses the format <em>object</em>@[[\slotname]] to
                    mean the internal slot [[\slotname]] of the object
                    <em>object</em>.</p>
                <p>The term <dfn>JSON-serializable object</dfn> used in this
                    specification means an object that can be serialized to a string
                    using <a>JSON.stringify</a> and later deserialized back to an
                    object using <a>JSON.parse</a> with no loss of data.</p>
                <p>When instructed to <dfn>Trim</dfn>(<var>x</var>), a user agent
                    MUST behave as if [[!ECMA-262-2015]]'s
                    <code>String.prototype.trim()</code> function had been called on
                    the string <var>x</var>.</p>
        -->
            </dd>
            <dt>DOM4</dt>
            <dd>
            <!--
                The <code><dfn>Event</dfn></code> type and the terms <dfn>fire
                an event</dfn>, <dfn>dispatch flag</dfn>, <dfn>stop propagation
                flag</dfn>, and <dfn>stop immediate propagation flag</dfn> are
                defined by [[!DOM4]].
            -->
                <p><dfn>DOMException</dfn> and the following DOMException types
                    from [[!DOM4]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>AbortError</dfn></code></td>
                        <td>The operation was aborted</td>
                    </tr>
                    <tr>
                        <td><code><dfn>InvalidStateError</dfn></code></td>
                        <td>The object is in an invalid state</td>
                    </tr>
                    <!--
                    <tr>
                        <td><code><dfn>NotSupportedError</dfn></code></td>
                        <td>The payment method was not supported</td>
                    </tr>
                    -->
                    <tr>
                        <td><code><dfn>SecurityError</dfn></code></td>
                        <td>The operation is only supported in a secure context</td>
                    </tr>
                    <tr>
                        <td><code><dfn>OperationError</dfn></code></td>
                        <td>The operation failed for an operation-specific reason.</td>
                    </tr>
                </table>
            </dd>
            <dt>WebIDL</dt>
            <dd>
            <!--
                When this specification says to <dfn>throw</dfn> an error, the
                <a>user agent</a> must throw an error as described in [[!WEBIDL]].
                When this occurs in a sub-algorithm, this results in termination of
                execution of the sub-algorithm and all ancestor algorithms until
                one is reached that explicitly describes procedures for catching
                exceptions.
            -->
                <p>The following DOMException types from [[!WEBIDL]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>NotAllowedError</dfn></code></td>
                        <td>The request is not allowed by the user agent or the
                        platform in the current context.</td>
                    </tr>
                </table>
                </dd>
        <dt>Secure Contexts</dt>
        <dd>The terms <dfn>secure context</dfn> is defined by the Secure
          Contexts specification [[!POWERFUL-FEATURES]].</dd>
        <dt>URL</dt>
        <dd>The <dfn>URL</dfn> concept and <dfn>URL parser</dfn> are
            defined in [[!WHATWG-URL]].</dd>
        <dt>Fetch</dt>
        <dd>The terms <dfn>Fetch</dfn>, <dfn>Request</dfn>, <dfn data-lt="body">Request Body</dfn>, <dfn data-lt="method">Request
            Method</dfn>, <dfn>Header List</dfn>, <dfn>Response</dfn>,
            <dfn>Context</dfn> and <dfn>Network Error</dfn> are defined in
            [[!FETCH]].</dd>
        <dt>Service Workers</dt>
        <dd>The terms 
          <dfn data-lt="service worker|service workers">service worker</dfn>
          <dfn>service worker registration</dfn>,
          <dfn>active worker</dfn>,
          <dfn>installing worker</dfn>,
          <dfn>waiting worker</dfn>,
          <dfn>handle functional event</dfn>,
          <dfn>extend lifetime promises</dfn>,
          and
          <dfn data-lt="scope url|scope urls">scope URL</dfn>
          are defined in [[SERVICE-WORKERS]].</dd>
    </dl>
</section>
<section id="model">
  <h2>Payment App Model and Design Considerations</h2>
  <p>This section (which may be temporary) intends to help build shared understanding of the capabilities and limitations of the specified model.</p>
  <section>
    <h3>General Considerations</h3>
    <ul>
      <li>This specification builds on PaymentRequest API.</li>
      <li>It defines mechanisms that may be used to support both Web-based and <a>native payment apps</a>. However, we anticipate
          that the ecosystem will also include proprietary approaches to some of the functionality defined here
          (e.g., for payment app registration or invocation).</li>
    </ul>
  </section>
  <section>
    <h3>Decoupling and Trust</h3>
    <ul>
<li>    A goal of this system is to decouple the payment methods used to pay from the software (payment apps) that implement those payment methods. By decoupling, merchants (and their payment service providers) can lower the cost of creating a checkout experience, users can have more choice in the software they use to pay, and payment app providers can innovate without imposing an integration burden on merchants.</li>
<li>    Users may choose to use "open" or "proprietary" payment methods, so the payment app ecosystem must support both. Users must be able to register payment apps of their choosing. We expect the user to have greater choice of third party payment apps for open payment methods than for proprietary payment methods. Examples of open payment methods include card payment and SEPA credit transfer.</li>
<li>    For privacy, the design should limit information about the user's environment available to merchant without user consent. That includes which payment apps the user has registered. For open payment methods, the merchant should not receive information about which payment app the user selected to pay unless the user consents to share that information. See <a href="https://github.com/w3c/browser-payment-api/issues/224">issue 224</a> for discussion about how merchant may track progress of a push payment.</li>
<li>    Although decoupling relieves merchants of implementing some aspects of the checkout experience, one consequence is that they give up some degree of control. This was already the case for proprietary payment methods, but for open payment methods such as cards, merchants (or their PSPs) will be entrusting some portion of data collection to third party payment apps.</li>
<li>The design therefore includes support for merchants to recommend payment apps and suggest the ordering of payment methods. The design should endeavor not to constrain how browsers make use of this information, only provide guidance to browser makers about taking into account both merchant and user preferences.</li>
<li>Here are preferences the system might support:
  <ul>
<li>        Accepted payment methods (payment methods the merchant accepts, and no others may be used; part of payment request API)</li>
<li>        Preferred payment methods (payee-specified order part of payment request API)</li>
<li>        Recommended payment apps (payment apps the merchant prefers, but others may be used)</li>
  </ul>
</li>
<li> The browser can use this information in conjunction with user preferences to:
  <ul>
    <li>   Filter payment apps (to matching payment methods)</li>
<li>        Order payment apps (according to merchant specified order)</li>
<li>        Display recommended payment apps (according to merchant recommended payment app order)</li>
    </ul>
</li>
</ul>
  </section>
  <section>
    <h3>Registration and Unregistration</h3>
    <ul>
      <li>Registration provides a way for browsers
	to remain aware of the user's payment apps across transactions.</li>
      <li>Registration is not a 
	prerequisite for using a payment app. In particular, a user
	should be able to pay with a payee-recommended payment app
	that the user has not yet registered. Note: this implies
	that payment apps (at least in some cases) should be designed
	to process requests without assuming prior registration.
	There may also be security implications (since we expect to
	rely on origin information as a security mechanism at registration).</li>
      <li>When registration is desired it might happen in a variety of ways:
	<ul>
	  <li>This working group will define an API available for all types of payment apps.</li>
	  <li>Native apps and browsers may have platform-specific ways to achieve the same (or similar) result.</li>
	</ul>
      </li>
      <li>We expect registrations to happen at various times (e.g., outside and inside of checkout), and with differing levels of
          user consent to modify their configuration within the user agent. In general, explicit consent should not be required
          while the user is within the context of the payment request UI. Here are some examples:
        <ul>
          <li>When the merchant recommends a payment app and the user selects it, registration can happen in that moment without
              additional user action or consent. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/34#issuecomment-245431139">notes from Rouslan</a> on registration upon selection of recommended payment app.</li>
          <li>When the user installs native payment app, registration could happen either through platform-specific mechanisms (or through this standard API) without additional user action beyond installation.</li>
          <li>Users visiting a Web site (e.g., merchant or bank) may wish to explicitly register payment apps, which would require explicit
              consent from the user. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/34#issuecomment-245431139">notes from Rouslan</a> on gating registration on user activation.</li>
        </ul>
      </li>
      <li>During registration as defined in this specification,
	information about enabled payment methods and available payment options is provided to the user agent.
          The user agent stores this information for subsequent actions (e.g., when matching payee-accepted payment methods). In this
          proposal, there are no requirements for a payment app to be able to respond to user agent queries for updated
          registration information. In this proposal, payment apps update the information that a user agent has stored about them
          by re-calling the registration API. (See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/36">issue 36</a>.)</li>
      <li>We expect browsers to distinguish themselves in how they balance different ease of registration and security.</li>
      <li>It is important for merchants and users to be able to trust the
	authenticity of payment apps. A starting point is to rely on origin information (e.g., if a payment app is registered on a Web site). In contexts where origin binding is not available (e.g., potentially in the case of recommended payment apps) other mechanisms should be considered to help establish authenticity (e.g., invocation-time confirmation of a digital signature of a claimed origin).</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Identification</h3>
    <ul>
<li>    For recommended payment apps we will need <a>payment app identifiers</a> (PAIs). See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/35#issuecomment-245747771">discussion around issue 35</a>.</li>
<li>    A PAI should include origin information. This origin information may be used in a variety of ways:
  <ul>
<li>        The origin information could enable browsers to provide the user with useful services when the user is browsing a site with the same origin (e.g., putting that payment app at the top of a list or otherwise highlighted).</li>
<li>        For a "proprietary" payment method with an associated origin, the browser can do some (security) checks by comparing the origin of the payment method and the payment app.</li>
  </ul>
<li>    A PAI should allow for granularity (e.g., payment app versioning); we should consider URLs.</li>
</ul>
  </section>
  <section>
    <h3>Payment App Matching</h3>
    <ul>
      <li>When the user invokes the Payment Request API (e.g., by "pushing the Buy button"), the user agent
          computes the intersection between payee-accepted payment methods and user-registered payment methods. It
          does this by comparing Payment Request API data (from the payee) and data provided during registration,
          invoking the comparison algorithm defined in
          [[!METHOD-IDENTIFIERS]]. The result is a list of
          matching payment options and recommended payment apps.</li>
      <li>Using information provided during registration (e.g., an app name or icon),the user agent displays matching
          payment options for selection by the user. The user agent may also display payee-recommended payment apps, which are
          displayed distinctly for the user. This mechanism is intended to support use cases such as a merchant
          recommending their own payment app to the user, or a payment app that they trust for a proprietary payment method.
	<p class="note" title="Browser selection features not in scope">The user agent may offer features to facilitate selection (e.g., launch a chosen payment app or option every time the
          user wants to pay at a given Web site); those features lie outside the scope of this specification.</p></li>
      <li>The user selects a payment option to make a payment. The user may also select a recommended payment app.</li>
    </ul>
  </section>
  <section>
    <h3>User Experience</h3>
    <ul>
      <li>The system should minimize user interaction for payment app registration, payment app selection, and payment credentials selection. Ideas include:
	<ul>
	  <li>When only one payment app matches, the browser does not require user selection to launch it.</li>
	  <li>The browser displays payment options for direct selection by the user, avoiding the need for the user to make a second selection within the payment app context. The payment app provides the browser with sufficient information to display payment options. It is still possible to launch the payment app upon selection of a payment option, and in some cases the payment app may return a response without further user interaction, depending on the nature of the payment method.</li>
	</ul>
      </li>
      <li>It is likely that this specification will include <em>guidance</em> rather than requirements about specific user experience optimizations.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Invocation and Response</h3>
    <ul>
      <li>Based on information provided at registration, the user agent "launches" the payment app and provides it with
        input data drawn from the Payment Request API. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/24">issue 24</a> for information about launching the payment app in a secure context.</li>
      <li>The user may interact with the payment app in a variety of ways to authorize payment, cancel the transaction,
          or carry out other activities supported by the payment app. This specification does not address payment app
          behavior other than accepting requests and returning responses to the user agent.</li>
      <li>This specification defines a means for the user agent to receive a response asynchronously once the user has
          authorized payment. The response becomes the response of the Payment Request API.</li>
    </ul>
  </section>
  <section>
    <h3>Network Considerations</h3>
    <ul>
      <li>This specification only describes communication between the
          user agent and the payment app. This includes an
          asynchronous mechanism for a payment app to return a payment
          response to the user agent. This specification does not
          (yet) address scenarios where the user agent does not
          receive the response (e.g., due to a crash or network
        outage). Network failure may be especially problematic in the
	case of a push payment; see <a href="https://github.com/w3c/browser-payment-api/issues/224">issue 224</a>, and so the Working Group is considering whether the specification should include a standard way to learn how to query a component for payment state information. For example, many systems use backchannel communications, so one idea is for the payee to provide a callback URL. This would allow (but not require) the payment app to communicate with the payee server until such time as all parties are satisfied they share the same view of the payment response. An alternative would be to provide the payment app and the user agent a channel so that communication continues until all parties are satisfied they share the same view of the payment response. This might involve caching payment responses.</li>
      <li>This specification does not address communication between the payee server and the payee Web app, or between
          the payment app and other parties (e.g., the payment app distributor, or directly to the merchant).</li>
    </ul>
  </section>
</section>
<section id="definitions">
  <h2>Definitions</h2>
  <div data-include="https://w3c.github.io/webpayments-ig/latest/common/terms.html"
       data-oninclude="restrictReferences">
  </div>
  <p class="issue">Updates needed for payment method option definition.</p>
  <section>
  <h3>Payment App Implementation Technology</h3>
  <dl>
    <dt><dfn id="dfn-browser-based-payment-app"
         data-lt="browser-based payment app|browser-based payment apps">
    browser-based payment app</dfn></dt>
    <dd>a <a>payment app</a> that runs in a <a>browser</a>. Browser-based
    payment apps may elect to display a user interface, or to operate without
    any user interaction. This decision is made at runtime, and may vary based
    on criteria of the app's choosing (such as how long it has been since the
    user last authenticated themselves).</dd>

    <dt><dfn id="dfn-native-payment-app" data-lt="native payment app|native payment apps">native payment app</dfn></dt>
    <dd>a payment app built with the operating system default technology stack that uses non-Web technologies.</dd>
    <dt><dfn id="dfn-native-payment-app">ignored payment app</dfn></dt>
    <dd class="issue">Need a definition for <a>ignored payment app</a></dd>

    <dt><dfn id="dfn-payment-app-identifier"
         data-lt="payment app identifier|payment app identifiers">
    payment app identifier</dfn></dt>
    <dd>
       A unique identifier for a <a>payment app</a> (e.g., from a <a>payment
       method</a> manifest file). This specification defines these identifiers
       as to be <a>service worker</a> <a>scope URLs</a>. As such, they are not
       expected to be dereferenced.
    </dd>
    <dt><dfn>payment app window</dfn></dt>
    <dd>
      A <a>service worker</a> <code>WindowClient</code> used by <a>browser-based
      payment apps</a> to interact with the user when doing so is necessary to
      complete the payment transaction.
    </dd>
  </dl>
  <p class="note" title="Payment Apps in scope">
    The Web Payments Working Group intends for this specification to apply to any payment app that the may be invoked by the user agent, whatever technologies have been used to implement the payment app.</p>
  </section>
  <section>
  <h3>Payment App Registration States</h3>
  <dl>
      <dt><dfn id="dfn-registered-payment-app">registered payment app</dfn></dt>
      <dd>a payment app that is "known" to the user agent for the purposes of the interactions described in this document.

      <div class="note" title="Platform-specific registration">
          This specification defines a registration mechanism. Other registration mechanisms might co-exist with this one
          (e.g., on some platforms there may be a way to register a payment app directly with the operating system).</div>
      </dd>
      <dt><dfn id="dfn-unregistered-payment-app">unregistered payment app</dfn></dt>
      <dd>a payment app that is not known to the user agent, either because it has never been registered, or because it has been unregistered.</dd>

	  <dt><dfn id="dfn-enabled-payment-app">enabled payment app</dfn></dt>
	  <dd>A <a>registered payment app</a> with at least one <a>enabled
	      payment method</a>.</dd>
  </dl>
  </section>
  <section>
  <h3>Payment App Selection States</h3>
  <dl>
    <dt><dfn id="dfn-matching-payment-app">matching payment app</dfn></dt>
    <dd>An <a>enabled payment app</a> that:
      <ul>
	<li>has at least one <a>enabled payment method</a> that the
	  <a>payee</a> accepts.</li>

	<li>is not an <a>ignored payment app</a>.</li>
      </ul>
    </dd>
      <dt><dfn id="dfn-recommended-payment-app">recommended payment app</dfn></dt>
      <dd>a payment app suggested by the payee that may be used to handle a specific payment request.
          <p class="issue" data-number="112" title="Recommended Payment Apps is still under discussion">
              The Working Group has not yet agreed that the system should support recommended payment apps.
              Inclusion might involve small changes to payment request API. The group has also discussed the idea of user agent-recommended payment apps, for example, when the user agent is aware of an app for a proprietary payment method. The current specification does not provide for user agent-recommended apps but could be extended to do so.</p>
      </dd>
      <dt><dfn id="dfn-displayed-payment-app">displayed payment app</dfn></dt>
	  <dd>A <a>matching payment app</a> or <a>recommended payment app</a> with at least one selectable payment option (i.e. presented by the browser for user selection).</dd>

      <dt><dfn id="dfn-selected-payment-app">selected payment app</dfn></dt>
      <dd>the payment app whose option has been selected by the user to make a payment, but not yet invoked.</dd>

      <dt><dfn id="dfn-invoked-payment-app">invoked payment app</dfn></dt>
      <dd>the <a>selected payment app</a> that the user agent has invoked (executed) and passed payment app input data.</dd>
  </dl>

  </section>
  <section>
  <h3><dfn>Payment Options</dfn></h3>
  <p class="note">We need a clearer introduction to the concept of a payment option, and how it relates to payment apps.</p>

  <dl>
      <dt><dfn id="dfn-available-payment-app">available payment option</dfn></dt>
      <dd>a payment option from a registered payment app available for selection, corresponding to at least one enabled payment method.</dd>

      <dt><dfn id="dfn-matching-payment-option">matching payment option</dfn></dt>
      <dd>an available payment option that has at least one enabled payment method accepted by the payee, or a recommended
          payment app with at least one supported payment method accepted by the payee.</dd>

      <dt><dfn id="dfn-selectable-payment-option">selectable payment option</dfn></dt>
      <dd>a matching payment option for which information has been displayed by the user agent to facilitate user selection,
          but that has not yet been selected. <strong>Note:</strong> Information about selectable payment apps may be
          displayed in a variety of modalities, including visual and aural.</dd>

    <dt><dfn id="dfn-selected-payment-option">selected payment option</dfn></dt>
    <dd>the payment option selected by the user to handle the payment request.</dd>

  </dl>
  </section>
  <section>
  <h3>Payment Method Support</h3>
  <dl>
      <dt><dfn id="dfn-supported-payment-method">supported payment method</dfn></dt>
      <dd>a payment method that a payment app has been designed to support however, this payment method may or may
          not currently be enabled. A payment app may support more than one payment method.</dd>

      <dt><dfn id="dfn-unsupported-method">unsupported payment method</dfn></dt>
      <dd>a payment method that cannot be enabled by a payment app. Updates to a payment app may cause an
          unsupported payment method to become supported, or vice-versa.</dd>

      <dt><dfn id="dfn-enabled-method">enabled payment method</dfn></dt>
      <dd>a supported payment method that a registered payment app is able to handle. The payment app must have at least
          one available payment option with the corresponding enabled payment method.
      <p class="note" title="Supported vs enabled Payment Methods">
          The difference between <strong>supported</strong> and <strong>enabled</strong> payment methods is one of design-time vs runtime consideration.
          A payment app supports all the payment methods it was designed to support however at runtime only a subset
          may be enabled due to configuration or other runtime requirements that may not have been met for all
          supported payment methods.
      </p>
</dd>

  </dl>
  </section>
  <section>
  <h3>Payment App Invocation and Response Data</h3>
  <dl>
    <dt><dfn id="dfn-app-request-data">payment app request data</dfn></dt>
    <dd>data provided to the invoked payment app by the user agent to initiate a payment request. This data is a subset
        of data input to the Payment Request API.
    <p class="note" title="JSON serialization">
        The data passed between the user agent and the payment app will be serialized as JSON data.
    </p>
    </dd>
    <dt><dfn id="dfn-app-response-data">payment app response data</dfn></dt>
    <dd>data returned by an invoked payment app to the user agent, typically after payment authorization or other action
        taken through the payment app. This data, which will vary according to payment method, is then passed through
        the Payment Request API as the payment response.</dd>
  </dl>
</section>
</section>
<section id="overview">
  <h2>Overview of Service-Worker-Based Approach</h2>

<p>In this specification we use <a>service workers</a>
    to connect browsers with browser-based payment apps. We do so for
    several reasons:</p>

    <ul>
      <li>
        Service workers provide a cleanly isolated execution context that allows
        the <a>payment app</a> to run with clean separation from the
        <a>payee</a> website.
      </li>
      <li>We can leverage the ways in which service workers already
          handle lifecycle management (registration, update, and removal of
          <a>payment apps</a>), enable offline use, etc.</li>
      <li>We can leverage service worker origins for security, especially
          when used in conjunction with origins associated with <a>payment
          method identifiers</a>.</li>
    </ul>

<p class="note">
  The use of service workers restricts <a>browser-based payment apps</a> so
  that they must run only in secure contexts. The introduction of this
  restriction is deliberate, due to the sensitivity of the role that payment
  apps play.
</p>

<p>Here is the flow envisioned by this document:</p>
  <ol>
    <li>Through registration, a <a>service worker</a> is created and
        associated with <a>payment methods</a>
        (and associated metadata).</li>
    <li>When the <code>payment request API</code> is called, the browser
        displays a list of registered service workers associated
        with matching payment methods (along with any other payment apps
        that may be available to the browser).</li>
    <lI>When the user selects a <a>browser-based payment
        app</a>, the corresponding <a>service worker</a> is activated, and
        it receives a <a>PaymentRequestEvent</a>.</li>
    <li>Once active, the <a>payment app</a> performs whatever steps are
        necessary to authenticate the user, process the payment, and return
        payment information to the <a>payee</a>. If interaction with the user
        is necessary, the <a>payment app</a> can open a <a>payment app
        window</a> for that purpose.</li>
    <li>Finally, once the <a>payment app</a> is finished with its processing, it
        resolves a <a>promise</a> passed to it in the event. This causes the
        <code>Promise&lt;PaymentResponse&gt;</code> returned from
        <code>PaymentRequest.show()</code> to resolve.</li>
  </ol>
</section>
<section id="registration">
    <h2>
      Payment App Registration
    </h2>
    <section>
    <h3>
      Extensions to the <a>ServiceWorkerRegistration</a> interface
    </h3>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerRegistration</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <pre id="service-worker-registration-idl" class="idl">
        partial interface ServiceWorkerRegistration {
          readonly attribute PaymentAppManager paymentAppManager;
        };
      </pre>
  </section>
  <section id="payment-app-manager">
  <h2>
    <a>PaymentAppManager</a> interface
  </h2>
      <pre id="payment-app-manager-idl" class="idl">
      interface PaymentAppManager {
        Promise&lt;void&gt; setManifest(PaymentAppManifest manifest);
        Promise&lt;PaymentAppManifest&gt; getManifest ();
      };
      </pre>
      <section id="set-manifest">
      <h3>
        PaymentAppManager.setManifest()
      </h3>
        <p>
            The <code><dfn>setManifest</dfn></code> method is used to enable a
            service worker to process <a>payment requests</a>, and to set the
            properties associated with the <a>payment app</a>.
        </p>
        <p>The <code>setManifest</code> method, when invoked, MUST run the
        following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            Let <var>manifest</var> be the value of the <code>manifest</code>
            argument.
          </li>
          <li>
            Let <var>registration</var> be the
            <code><a>PaymentAppManager</a></code>'s associated <a>service
            worker registration</a>.
          </li>
          <li>If <var>registration</var> has no <a>active worker</a>, run the following substeps:
            <ol>
              <li>If <var>registration</var> has no <a>installing worker</a> and no <a>waiting
              worker</a>, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
              name is "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Wait for the <a>installing worker</a> or <a>waiting worker</a> of
              <var>registration</var> to become its <a>active worker</a>.
              </li>
              <li>If <var>registration</var> fails to activate either worker, reject
              <var>promise</var> with a <code><a>DOMException</a></code> whose name is
              "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Once <var>registration</var> has an <a>active worker</a>, proceed with the steps
              below.
              </li>
            </ol>
          </li>
          <li>
            Ask the user whether they allow the <a>payment app</a> to be
            registered to handle the indicated <a>payment methods</a>
            (unless a prearranged trust relationship applies or the user has
            already granted or denied permission explicitly for this <a>payment
            app</a>).
          </li>
          <li>
            If permission is not granted, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>NotAllowedError</a></code>" and terminate these steps.
          </li>
          <li>
            Register the <a>payment app</a> with the browser for future use,
            associating <var>manifest</var>'s <code>label</code> and
            <code>icon</code> with the payment app for user reference.
          </li>
          <li>
            For each <a>PaymentAppOption</a> present in the
            <code>options</code> field of the <var>manifest</var>:
            <ol>
              <li>
                Add a new payment option to the <a>payment app</a>'s
                registration, associating it with the <a>PaymentAppOption</a>
                <code>label</code> and <code>icon</code> fields.
              </li>
              <li>
                For each <a>payment method</a> indicated in the
                <a>PaymentAppOption</a>'s <code>enabledMethods</code>
                field, associate the payment option and the <a>payment app</a>
                with the payment method for future use.
              </li>
            </ol>
          </li>
          <li>
            Resolve <em>promise</em> with <code>undefined</code>.
          </li>
        </ol>
      </section>
      <section id="get-manifest">
      <h3>
        PaymentAppManager.getManifest()
      </h3>
        <p>
            The <code><dfn>getManifest</dfn></code> method is used to
            retrieve the properties associated with a registered
            <a>payment app</a>.
        </p>
        <p>The <code>getManifest</code> method, when invoked, MUST run the
        following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            If there is no <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>, reject <var>promise</var> with a 
            <a>DOMException</a> whose name is "<code><a>AbortError</a></code>"
            and terminate these steps.
          </li>
          <li>
            Retrieve the <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>.
          </li>
          <li>
            Let <var>manifest</var> be the retrieved <a>PaymentAppManifest</a>.
          </li>
          <li>
            Resolve <em>promise</em> with <var>manifest</var>.
          </li>
        </ol>
      </section>
  </section>
  <section id="payment-app-manifest">
  <h2>
    <a>PaymentAppManifest</a> interface
  </h2>
      <pre id="payment-app-manifest-idl" class="idl">
      dictionary PaymentAppManifest {
        DOMString label;
        DOMString? icon;
        sequence&lt;PaymentAppOption&gt; options;
      };
      </pre>
        <dl>
            <dt><code>label</code> member</dt>
            <dd>
                The <code>label</code> member is a string that represents the
                label for this <a>payment app</a> as it is usually displayed
                to the user.
            </dd>
            <dt><code>icon</code> member</dt>
            <dd>
                The <code>icon</code>member defines an icon for this
                <a>payment app</a> as it is usually displayed to the user.
            </dd>
            <dd class="issue">
                Need to define how an icon would be represented in this data.
                Url? Data URL? Size options?
            </dd>
            <dt><code>options</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-manifest-options"><code>options</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option.
            </dd>
        </dl>
  </section>
  <section id="payment-app-options">
  <h2>
    <a>PaymentAppOption</a> dictionary
  </h2>
      <pre id="payment-app-options-idl" class="idl">
      dictionary PaymentAppOption {
        DOMString label;
        DOMString? icon;
        DOMString id;
        sequence&lt;DOMString&gt; enabledMethods;
      };
      </pre>
        <dl>
            <dt><code>label</code> member</dt>
            <dd>
                The <code>label</code> member is a string that represents the
                label for this option as it is usually displayed to the user
                when selecting a payment app.
            </dd>
            <dt><code>icon</code> member</dt>
            <dd class="issue">
                Need to define how an icon would be represented in this data.
                Url? Data URL? Size options?
            </dd>
            <dt><code>id</code> member</dt>
            <dd>
                The <code>id</code> member is an identifier, unique
                within the <a>PaymentAppManifest</a>, that will be passed to the
                payment app to indicate which <a>PaymentAppOption</a> the user
                selected.
            </dd>
            <dt><code>enabledMethods</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-option-enabled-methods"><code>enabledMethods</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option.
            </dd>
        </dl>
  </section>
  <section id="register-example">
  <h3>
    Registration Example
  </h3>
    <p>The following example shows how to register a <a>browser-based payment
    app</a>:</p>
       <pre class="example highlight" title="Payment App Registration">
         navigator.serviceWorker.register('/exampleapp.js')
         .then(function(registration) {
           return registration.paymentAppManager.setManifest({
             label: "ExampleApp",
             icon: "...",
             options: [
               {
                 label: "Visa ending ****4756",
                 icon: "...",
                 id: "dc2de27a-ca5e-4fbd-883e-b6ded6c69d4f",
                 enabledMethods: ["basic-card#visa"]
               },
               {
                 label: "My Bob Pay Account: john@example.com",
                 icon: "...",
                 id: "c8126178-3bba-4d09-8f00-0771bcfd3b11",
                 enabledMethods: ["https://bobpay.com/"]
               },
               {
                 label: "Add new credit/debit card to ExampleApp",
                 icon: "...",
                 id: "new-card",
                 enabledMethods: [
                   "basic-card#visa",
                   "basic-card#mastercard",
                   "basic-card#amex"
               }
             ]
           });
         }).then(function() {
           console.log("Installed payment app from /paymentapp.js"); // Success!
         }).catch(function(error) {
           console.log(error);
         });
     </pre>
     <p class="issue" title="Payment method identifiers">
       The Editors will update the payment method identifier syntax in this
       and other examples to align with [[!METHOD-IDENTIFIERS]], once a final
       format has been agreed upon.
     </p>
  </section>

  <section id="native-app-registration">
  <h3>
    Native App Registration
  </h3>
  <p class="issue" title="Registration of native payment apps?">
      What, if anything, should we say about registering <a>native payment
      apps</a>?
  </p>
  <p class="note" title="Origin for native apps">
    <a>Native payment apps</a> could be registered from Web pages <em>(is this
    true?)</em>, thus allowing the association of an origin to a <a>native
    payment app</a>.
  </p>
  </section>
</section>
<section id="matching">
  <h2>Payment App Matching</h2>
  <div class="issue" title="Dependency on Payment Method Identifiers spec">
      <p>
          We anticipate that [[!METHOD-IDENTIFIERS]] will define the PMI matching algorithm. This
          specification will explain how to invoke that algorithm using data available from the Payment Request API input
          and payment method information aggregated from:
      </p>
      <ul>
          <li>enabled payment methods across all payment options of registered payment apps.</li>
          <li>supported payment methods of recommended but unregistered payment apps.</li>
      </ul>
  </div>
</section>
<section id="selection">
  <h2>Payment App Selection</h2>
  <section>
    <h3>Selectable App Information Display</h3>
    <p class="issue" title="Need to define display algorithm">
        After matching the user agent will have a list of payment options that the user can select to handle the
        payment request. How will these be ordered when they are displayed to the user, where do recommended apps
        fit in to the order and how do we treat apps that are both registered and recommended?
    </p>
    <p class="issue" title="Should payment instrument details be included?" data-number="12">
        What information is needed by the user agent to display selectable apps/options? This needs to be captured
        during registration.
    </p>
    <p>
      The output of the payment method matching algorithm will be a list of matching payment options from registered
      payment apps and a list of recommended payment apps. The user agent will present this list of options to the user
      so they can select how they want to handle the payment request.
    </p>
    <ul>
      <li>The user agent <span class='rfc2119'>MUST</span> display all matching payment options.</li>
      <li>The user agent <span class='rfc2119'>MAY</span> display recommended payment apps.</li>
      <li>In its display, the user agent <span class='rfc2119'>MUST</span> distinguish recommended payment apps from
          payment options from registered payment apps.</li>
      <li>The user agent <span class='rfc2119'>MAY</span> allow the user to configure the display of matching payment
          options to control the ordering and define preselected defaults.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> display matching payment options in an order that corresponds
          to the order of supported payment methods supplied by the payee, except where the user agent enables the user
          to override this order.</li>
      <li>The user agent <span class='rfc2119'>SHOULD</span> display any payee-recommended apps in the order specified
          by the payee.</li>
    </ul>

    <div class="issue" title="Payment app selection user experience consistency">
        <p>We have identified a number of <a href="https://github.com/w3c/webpayments/wiki/PaymentApp_Notes#user-experience-descriptions">user experiences</a> that we would like to harmonize. Just a few examples here:</p>
        <ol>
          <li>User has no registered payment apps.</li>
          <li>User has apps with supported but no enabled payment methods.</li>
          <li>User has apps with supported and enabled payment methods.</li>
          <li>Merchant wishes to recommend a payment app to the user.</li>
          <li>User agent wishes to recommend a payment app that supports a payment method for which the user does not
              currently have a supporting payment app.</li>
        </ol>
    </div>

    <section class="informative">
      <h4>Examples of Ordering of Selectable Payment Apps</h4>
      <p>The following are examples of user agent display behavior.</p>
      <ul>
        <li>Display a user-configured preferred payment app at the top of a list of matching payment apps.</li>
	<li>Display a payee-recommended app that the user has also registered at the top of a list.</li>
        <li>Enable the user to set a default payment app for a Web site, and display that payment at the top of a list for that site.</li>
        <li>Enable the user to set a default payment app for a Web site (e.g., the payment app distributed by that
            retailer), and display that payment at the top of a list for that
          site.</li>
	<li>Based on how frequently the user has selected a payment app, the browser can automatically display that one closer to the top of a list.</li>
	<li>If the user initiates a purchase on a site with the same origin as that associated with a payment app, display that app at the top of a list.</li>
      </ul>
    </section>
  </section>
  <section>
    <h3>Selection by the User</h3>
    <ul>
      <li>The user agent  <span class='rfc2119'>MUST</span> enable the user to
      select any <a>displayed payment app</a>.</li>
      <li>If the user selects an unregistered recommended payment app, the user agent <span class='rfc2119'>SHOULD</span>
          offer the user an opportunity to register it.</li>
    </ul>
  </section>
</section>
<section id="invocation">
  <h2>Payment App Invocation, Display and Response</h2>
  <p>
      Once the user has selected a payment option, the user agent is
      responsible for preparing <a>payment app request data</a>, invoking the
      payment app, providing the request data to the payment app, and
      returning the payment app response through the Payment Request API.
  </p>
  <section id="sec-app-request-data">
    <h3>Payment App Request Data</h3>
    The <a>payment app request data</a> is conveyed using the following
    dictionary:
    <pre class="idl">
      dictionary PaymentAppRequestData {
        DOMString origin;
        sequence&lt;PaymentMethodData&gt; methodData;
        PaymentItem total;
        sequence&lt;PaymentDetailsModifier&gt; modifiers;
        DOMString optionId;
      };
    </pre>
    <dl>
      <dt><code>origin</code> attribute</dt>
      <dd>
        This attribute a string that indicates the <a>origin</a> of the
        <a>payee</a> web page. It MUST be formatted according to the
        "<a href="https://tools.ietf.org/html/rfc6454#section-6.1">Unicode
        Serialization of an Origin</a>" algorithm defined in section 6.1 of
        [[!RFC6454]].
      </dd>
      <dt><code>methodData</code> attribute</dt>
      <dd>
        This attribute contains <code>PaymentMethodData</code>
        dictionaries containing the <a>payment method identifiers</a> for the
        <a>payment methods</a> that the web site accepts and any associated
        <a>payment method</a> specific data.
        It is populated from the
        <a>PaymentRequest</a> using the <a>Method Data Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>total</code> attribute</dt>
      <dd>
        This attribute indicates the total amount being requested for payment.
        It is initialized with a <a>structured clone</a> of the
        <code>total</code> field of the <code>PaymentDetails</code> provided
        when the corresponding <a>PaymentRequest</a> object was instantiated.
      </dd>
      <dt><code>modifiers</code> attribute</dt>
      <dd>
        This sequence of <code>PaymentDetailsModifier</code> dictionaries
        contains modifiers for particular payment method identifiers (e.g.,
        if the payment amount or currency type varies based on a
        per-payment-method basis).  It is populated from the
        <a>PaymentRequest</a> using the <a>Modifiers Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>optionId</code> attribute</dt>
      <dd>
        This attribute indicates which <a>PaymentAppOption</a> the user
        selected. It corresponds to the <code>id</code> field provided during
        payment app registration.
      </dd>
    </dl>
    <section>
      <h3>
        <dfn>Method Data Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>methodData</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>dataList</var> to the newly created <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\methodData]]</var> in the
          corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inData</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inData</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentMethodData</code> object.
            </li>
            <li>
              Set <var>outData</var> to the newly created
              <code>PaymentMethodData</code>.
            </li>
            <li>
              Set <var>outData</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outData</var>.data to a <a>structured clone</a> of
              <var>inData</var>.<code>data</code>.
            </li>
            <li>
              Append <var>outData</var> to <var>dataList</var>.
            </li>
          </ol>
          <li>
            Set <code>methodData</code> to <var>dataList</var>.
          </li>
      </ol>
    </section>
    <section>
      <h3>
        <dfn>Modifiers Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>modifiers</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>modifierList</var> to the newly created
          <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\paymentDetails]]</var>.<code>modifiers</code>
          in the corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inModifier</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inModifier</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentDetailsModifier</code> object.
            </li>
            <li>
              Set <var>outModifier</var> to the newly created
              <code>PaymentDetailsModifier</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>total</code> to a <a>structured
              clone</a> of <var>inModifier</var>.<code>total</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>additionalDisplayItems</code>
              to a <a>structured clone</a> of
              <var>inModifier</var>.<code>additionalDisplayItems</code>.
            </li>
            <li>
              Append <var>outModifier</var> to <var>modifierList</var>.
            </li>
          </ol>
          <li>
            Set <code>modifiers</code> to <var>modifierList</var>.
          </li>
      </ol>
    </section>
  </section>
  <section>
    <h3>Payment App Invocation</h3>
    <p>
      <a>Payment apps</a> are invoked when a <a>payee</a> requests a payment
      by calling <code>PaymentRequest.show()</code> and the user selects a
      payment app (or has one implicitly selected by previously established
      user preferences). If the user selects a <a>browser-based payment
      app</a> to service the request, the <a>service worker</a> corresponding
      to that application receives an event with the
      <a>PaymentAppRequestData</a> containing information about the payment
      being requested. The event also contains a function that allows the
      payment app to provide a <a>payment response</a> back to the
      <a>payee</a>. This process is formally described in the following
      sections.
    </p>
    <section>
    <h3>
      Extension to <code>ServiceWorkerGlobalScope</code>
    </h3>
      <p>
        The Service Worker specification defines a
        <code>ServiceWorkerGlobalScope</code> interface [[!SERVICE-WORKERS]],
        which this specification extends.
      </p>
      <pre class="idl">
        partial interface ServiceWorkerGlobalScope {
          attribute EventHandler onpaymentrequest;
        };
      </pre>
      <dl>
        <dt><code>onpaymentrequest</code> attribute</dt>
        <dd>
          The <code>onpaymentrequest</code> attribute is an <a>event handler</a>
          whose corresponding <a>event handler event type</a> is
          <code>paymentrequest</code>.
        </dd>
      </dl>

      <p>The <a>PaymentRequestEvent</a> interface represents a received
      <a>payment request</a>.
    </section>
    <section>
    <h3>
      The <code>paymentrequest</code> Event
    </h3>
      <p>
        The <a>PaymentRequestEvent</a> represents a received <a>payment
        request</a>.
      </p>
      <pre class="idl">
      [Exposed=ServiceWorker]
      interface PaymentRequestEvent : ExtendableEvent {
        readonly attribute PaymentAppRequestData data;
        void respondWith((<a>Promise</a>&lt;<a>PaymentResponse</a>&gt;
        or <a>PaymentResponse</a>) r);
      };
      </pre>
      <dl>
        <dt><code>data</code> attribute</dt>
        <dd>
          This attribute contains the <a>payment app request data</a> associated
          with this <a>payment request</a>.
        </dd>
        <dt><code>respondWith</code> method</dt>
        <dd>
          This method is used by the payment app to provide a
          <a>PaymentResponse</a> when the payment successfully completes.
        </dd>
      </dl>
        <p>
          Upon receiving a <a>payment request</a> by way of
          <code>PaymentRequest.show()</code> and subsequent user selection of a
          <a>browser-based payment app</a>, the <a>user agent</a> MUST run
          the following steps or their equivalent:
        </p>
        <ol>
          <li>Let <var>registration</var> be the <a>service worker
          registration</a> corresponding to the <a>browser-based payment app</a>
          selected by the user.
          </li>
          <li>If <var>registration</var> is not found, reject the Promise that
            was created by <code>PaymentRequest.show()</code> with a
            <a>DOMException</a> whose value "<a>InvalidStateError</a>" and
            terminate these steps.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with a
          <a>service worker registration</a> of <var>registration</var> and
          <var>callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object that was provided
                  as an argument.  </li>
              <li>Create a <a>trusted event</a>,
                  <var>e</var>, that uses the
                  <code><a>PaymentRequestEvent</a></code> interface, with the
                  event type <code>paymentrequest</code>, which does not bubble,
                  cannot be canceled, and has no default action.  </li>
              <li>Set the <code>data</code> attribute of
                  <var>e</var> to a new <a>PaymentAppRequestData</a> instance,
                  populated as described in
                  <a href="#sec-app-request-data"></a>.
              </li>
              <li>Dispatch <var>e</var> to <var>global</var>.</li>
              <li>Wait for all of the promises in the <a>extend lifetime
                  promises</a> of <var>e</var> to resolve.</li>
              <li>If the <a>payment app</a> has not provided a <a>payment app
                  response</a> as described in <a
                  href="#sec-payment-app-response"></a>, reject the Promise that
                  was created by <code>PaymentRequest.show()</code> with a
                  <a>DOMException</a> whose value "<a>OperationError</a>".
            </ol>
          </li>
        </ol>
    </section>
  </section>
  <section>
  <h3>
    Payment App Display
  </h3>
    <p>
      Payment Apps that require user input can open a payment window using the
      <code>clients.openWindow()</code> method defined in [[!SERVICE-WORKERS]].
      Absent user preferences that override such behavior, user interaction is
      required during payment requests, in the form of payment app selection. As
      a consequence, the user agent MUST treat a <a>paymentrequest</a> event as
      user interaction for the purposes of determining whether the <a>service
      worker</a> is allowed to open a window.
    </p>
    <p class="note">
      The actual rendering of a <a>payment app window</a> is a browser
      implementation detail. While opening an entirely new window is possible,
      it is more likely that the contents will be rendered in a way that makes
      it more obvious that the interactions pertain to the payment
      transaction. This is an area for potential user agent experimentation
      and differentiation. The opening of a <a>payment app window</a> versus
      other types of windows can be distinguished based on the event type the
      user agent is using to grant permission to open a window.
    </p>
    <p><em>The remainder of this section is a non-normative explanation of how
    the service worker <code>WindowClient</code> class can be used to interact
    with users.</em></p>
    <p>
      Upon calling clients.openWindow(), the payment app receives a
      <a>Promise</a> which resolves to a <code>WindowClient</code>. For the
      purposes of this discussion, we will refer to this
      <code>WindowClient</code> as <var>client</var>.  The payment app can use
      the <var>client</var>.<code>postMessage()</code> method to send messages
      to the <a>payment app window</a>.
    </p>
    <p>
      When a <a>payment app window</a> receives the <code>message</code> event
      from the payment app, this event will contain a <code>source</code>
      attribute which indicates the payment app's service worker. The payment
      app window can then call <code>source.postMessage()</code> to send a
      response to the payment app. Once the payment app window has complete its
      interaction with the user, it closes the window and uses this
      <code>postMessage()</code> call to return information to the payment app.
    </p>
    <p class="issue">
      In order for this approach to work, we have to treat a
      <a>paymentrequest</a> as permission to open a popup, which is a formal
      property relied up on by [[!SERVICE-WORKERS]]. We need to be careful
      that this does not become an end-run around exiting pop-up protections.
    </p>
    <p class="issue">
      Do we want to define a new <code>FrameType</code> for <a>payment app
      window</a>s? This requires input from someone with detailed knowledge of
      service worker design.
    </p>
  </section>
  <section id="sec-payment-app-response">
    <h3>Payment App Response</h3>
    <p>
      The user agent receives a successful response from the payment app
      through resolution of the Promise provided to the <code>respondWith</code>
      function of the corresponding <a>PaymentRequestEvent</a> dictionary.
      The application is expected to resolve the Promise with a
      <code>PaymentResponse</code> dictionary instance containing the payment
      response information.
    </p>
    <p>
      When this Promise is resolved, the user agent MUST run the <a>user
      accepts the payment request algorithm</a> as defined in
      [[!PAYMENT-REQUEST-API]], replacing steps 6 and 7 with these steps or
      their equivalent:
    </p>
    <ol>
      <li>
        Set <var>appResponse</var> to the <code>PaymentResponse</code> used to
        resolve the <a>PaymentRequestEvent</a><code>.respondWith</code> Promise.
      </li>
      <li>
        If <var>appResponse</var>.<code>methodName</code> is not present or
        not set to one of the values from
        <a>PaymentRequestEvent</a>.<code>data</code>, reject the Promise
        created by <code>PaymentRequest.show()</code> with <a>DOMException</a>
        whose value "<a>InvalidStateError</a>" and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>methodName</code>
        and assign it to
        <var>response</var>.<code>methodName</code>.
      </li>
      <li>
        If <var>appResponse</var>.<code>details</code> is not present,
        reject the Promise created by
        <code>PaymentRequest.show()</code> with a <a>DOMException</a> whose
        value is "<a>InvalidStateError</a>" and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>details</code>
        and assign it to
        <var>response</var>.<code>details</code>.
      </li>
    </ol>
    <p>
      The user agent receives a failure response from the payment app through
      rejection of the Promise.  The user agent MUST use the rejection reason
      to reject the Promise that was created by
      <code>PaymentRequest.show()</code>.
    </p>

    <p>The following example shows how to respond to a payment request:</p>
    <pre class="example highlight" title="Sending a Payment Response">
      paymentRequestEvent.respondWith(new Promise(function(accept,reject) {
        /* ... processing may occur here ... */
        accept({
          methodName: "basic-card#visa",
          details: {
            card_number :  "1232343451234",
            expiry_month : "12",
            expiry_year :  "2020",
            cvv :          "123"
           }
        });
      });
    </pre>
     <p class="issue" title="Generic callback back-channel for the payment
     response transmission">
       Some payment methods might require a back channel to guarantee payment
       response delivery (especially push payment methods).  Should it be part
       of the generic portion of paymentRequest and paymentResponse? [Ed Note:
       the "complete()" attribute of the "PaymentResponse" interface would serve
       this purpose quite cleanly.]
     </p>
  </section>
  <section id="post-example">
  <h3>Example using HTTP POST</h3>
    <p>
      This example codes shows how to use this API using a scheme a scheme in
      which a <code>POST</code> is sent to a URL with the payment request as a
      body. The response is allowed to be either <code>application/json</code>
      (which is inferred to contain a payment response), or
      <code>text/html</code> (which contains content to be rendered to the
      user).
    </p>
    <pre class="example highlight" title="Simple POST-based Payment App"
    id="example-post-payment-app">
      var contentType;
      var paymentPromise;
      /* Handle payment request from a payee */
      self.addEventListener('paymentrequest', function(e) {
        paymentPromise = new Promise(function(accept, reject) {
          fetch("https://www.example.com/bobpay/process",
            { method: "POST",  body: JSON.stringify(e.data) })
          .then(function(response) {
            contentType = response.headers.get("content-type");
            if (!contentType) {
              throw new Error("No content type header");
            }
            return response.text();
          }).then(function(body) {
            if(contentType.indexOf("application/json") !== -1) {
              /* Respond to the payment request with the received body */
              accept(JSON.parse(body));
            } else if (contentType.indexOf("text/html") !== -1) { {
              /* Open a new payment window and populate it with the
                 document returned from the response */
              var url = "data:text/html;base64," + btoa(body);
              clients.openWindow(url).then(function(windowClient) {
                windowClient.postMessage(e.data);
              });
            } else {
              throw new Error("Unexpected value in content type header");
            }
          }).catch(function(err) {
            reject(err);
          });
        e.respondWith(paymentPromise);
      });

      /* Handle payment response from a payment app window */
      self.addEventListener('message', function(e) {
        if (e.data.hasOwnProperty('name')) {
          paymentPromise.reject(e.data);
        } else {
          paymentPromise.resolve(e.data);
        }
      });
    </pre>
    <p>Using the simple scheme described above, a trivial HTML page that is
    loaded into the <a>payment app window</a> to implement the <em>basic
    card</em> scheme might look like the following:</p>
    <pre class="example highlight" title="Simple Payment App Window">
&lt;html&gt; &lt;body&gt; &lt;form id="form"&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Card Number:&lt;/th&gt;&lt;td&gt;&lt;input name="card_number"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Month:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_month"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Year:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_year"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;CVV:&lt;/th&gt;&lt;td&gt;&lt;input name="cvv"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="submit" value="Pay"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;script&gt;
window.addEventListener("message", function(e) {
  var form = document.getElementById("form");
  /* Note: message sent from payment app is available in e.data */
  form.onsubmit = function() {
    var details = {};
    ["card_number","expiry_month","expiry_year","cvv"].forEach(function(field) {
      details[field] = form.elements[field].value;
    });
    e.source.postMessage({
      methodName: "basic-card#visa",
      details: details
    });
    window.close();
  }
});
&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
    </pre>

  </section>

</section>
<section id="security">
  <h2>Security and Privacy Considerations</h2>
  <section>
    <h3>Design Considerations</h3>
    <ul>
      <li>The API does not share information about the user's registered payment methods or payment apps with the payee. The only information that is shared is the result of user selection.</li>
    </ul>
  </section>
  <section>
    <h3>Secure Communications</h3>
    <ul>
      <li>See <a href="https://www.w3.org/TR/service-workers/#security-considerations">Service Worker security considerations</a></li>
      <li>Payment method security is outside the scope of this specification and is addressed by payment apps that support those payment methods.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Authenticity</h3>
    <ul>
      <li>To avoid problems such as phishing-type attacks on payee sites, we want to be able to ensure the authenticity of payment apps. In general we expect to rely on origin information for establishing payment app authenticity. In contexts where payment apps are referenced other than on their origin, we are considering additional measures to help establish authenticity. Examples: validate a digital signature prior to launching a recommended app or an installed native app without associated origin information.</li>
    </ul>
  </section>
  <section>
    <h3>Data Validation</h3>
    <ul>
      <li>Payees should validate that the data they have received through the paymentRequest API is what they expect (e.g., the total that was paid, etc.).</li>
    </ul>
  </section>
  <section>
    <h3>Private Browsing Mode</h3>
    <ul>
      <li>When the Payment Request API is invoked in a "private browsing mode," the browser should launch browser-based payment apps in a private context. This will generally prevent sites from accessing any previously-stored information. In turn, this is likely to require either that the user log in to the payment app or re-enter payment instrument details.</li>
    </ul>
  </section>
</section>
</body>
</html>
