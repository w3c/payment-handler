<!DOCTYPE html>
<html>
<head>
  <title>Payment App API</title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src='utils.js' class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            shortName:  "payment-apps",
            edDraftURI:   "https://w3c.github.io/webpayments-payment-apps-api/",
            specStatus: "ED",
            editors: [
                {   name:       "Adrian Hope-Bailie",
                    url:        "https://github.com/adrianhopebailie",
                    company:    "Ripple",
                    companyURL: "https://ripple.com"
                },
                {   name:       "Tommy Thorsen",
                    url:        "https://github.com/tommythorsen",
                    company:    "Opera",
                    companyURL: "https://opera.com"
                },
                {   name:       "Adam Roach",
                    url:        "https://github.com/adamroach",
                    company:    "Mozilla",
                    companyURL: "https://mozilla.org"
                },
                {   name:       "Jason Normore",
                    url:        "https://github.com/jnormore",
                    company:    "Shopify",
                    companyURL: "https://shopify.com"
                },
                {   name:       "Ian Jacobs",
                    url:        "http://www.w3.org/People/Jacobs/",
                    company:    "W3C",
                    companyURL: "https://www.w3.org/"
                },
            ],

            useExperimentalStyles: true,
            license:      "w3c-software-doc",

            wg:           "Web Payments Working Group",
            wgURI:        "https://www.w3.org/Payments/WG/",
            wgPublicList: "public-payments-wg",
            wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83744/status",

            issueBase:    "https://github.com/w3c/webpayments-payment-apps-api/issues/",

            localBiblio:  {
                "PAYMENT-REQUEST-API": {
                    title:    "Payment Request API",
                    href:     "http://www.w3.org/TR/payment-request/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurray"
                    ],
                    status:   "FPWD"
                },
                "METHOD-IDENTIFIERS": {
                    title:    "Payment Method Identifiers",
                    href:     "https://www.w3.org/TR/payment-method-id/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurry"
                    ],
                    status:   "FPWD"
                }
            }
        };
    </script>
    <style>
        dt { margin-top: 0.75em; }
        table { margin-top: 0.75em; border-collapse:collapse; border-style:hidden hidden none hidden }
        table thead { border-bottom:solid }
        table tbody th:first-child { border-left:solid }
        table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
        li { margin-top: 0.5em; margin-bottom: 0.5em;}
    </style>
</head>
<body>
<section id='abstract'>
  <p>The Payment Request API [[!PAYMENT-REQUEST-API]] provides
    a standard way to initiate payment requests from Web pages and
    applications. User agents implementing that API prompt the user
    to select a way to handle the payment request, after which
    the user agent returns a payment response to the originating site.
    This specification adds <strong>payment apps</strong>
    to that user experience. It defines how users
    register payment apps with user agents, how user agents support the display of
    information about payment apps the user can select to handle the
    payment request, how the user selects a payment app, and how communication takes
    place between user agents and payment apps to fulfill the requirements of the
    underlying Payment Request API.</p>
</section>
<section id='sotd'>
    <p>The Web Payments Working Group maintains <a href="https://github.com/w3c/webpayments-payment-apps-api/issues">
        a list of all bug reports that the group has not yet addressed</a>.
        This draft highlights some of the pending issues that are still to
        be discussed in the working group. No decision has been taken on
        the outcome of these issues including whether they are valid. Pull
        requests with proposed specification text for outstanding issues
        are strongly encouraged.</p>
</section>
<section class='informative'>
  <h2>Introduction</h2>

  <p>The Web Payments Working Group seeks to streamline payments on the Web to
  help reduce payment "abandonment" and make it easier to use
  new payment methods on the Web. It has published the Payment Request
  API [[!PAYMENT-REQUEST-API]] as a standard way to initiate payment
  requests from Web pages and applications. This specification adds
    payment apps to that user experience. A payment app is software that
    enables the user to fulfill a payment request using the user's
    preferred payment method.</p>

    <p>This specification defines:</p>
    <ul>
      <li>How users register and unregister payment apps with the user agent.</li>
      <li>How the user agent matches payment methods supported by the payee with those enabled in registered payment apps.</li>
      <li>How the user agent displays information about payment apps to the user for selection.</li>
      <li>How the user agent invokes a payment app, communicates input/response data with it, and returns the response data to the underlying Payment Request API.</li>
    </ul>
  <p>Payment apps may be implemented in a variety of ways: as Web applications, native operating system applications,
      user agent extensions, built-in user agent components, interface-less Web services, or a combination.
      This specification does not cover every aspect of communication on every platform.</p>
  <p class="note" title="User agent as payment request mediator">The Web Payments Working Group has used the term
      "mediator" to refer to the software (here, the user agent) that carries out the activities defined in this
      specification (matching, information display, etc.).</p>
</section>
<section id='conformance'>
    <p>
        This specification defines one class of products:
    </p>
    <dl>
        <dt><dfn>Conforming user agent</dfn></dt>
        <dd>
            <p>
                A <a>user agent</a> MUST behave as described in this specification
                in order to be considered conformant. In this specification, <a>user agent</a> means a <em>Web
                browser or other interactive user agent</em> as defined in [[!HTML5]].
            </p>
            <p>
                User agents MAY implement algorithms given in this
                specification in any way desired, so long as the end result is
                indistinguishable from the result that would be obtained by the
                specification's algorithms.
            </p>
            <p>
                A conforming Payment App API user agent MUST also be a
                <em>conforming implementation</em> of the IDL fragments
                of this specification, as described in the
                “Web IDL” specification. [[!WEBIDL]]
            </p>

            <aside class="note">
                This specification uses both the terms "conforming user agent(s)"
                and "user agent(s)" to refer to this product class.
            </aside>
        </dd>
    </dl>
</section>
<section id="dependencies">
  <h3>Dependencies</h3>
  <p>This specification relies on several other underlying specifications.</p>
    <dl>
        <!--
          <dt>Payment Request Architecture</dt>
          <dd>The term <dfn data-lt="payment method|payment methods">Payment Method</dfn>
	    is defined by the Payment Request Architecture document
        [[PAYMENT-ARCH]].</dd>
        -->
        <dt>Payment Request API</dt>
        <dd>The terms
            <dfn>PaymentRequest</dfn>, <dfn>PaymentResponse</dfn>,
            and
            <dfn>user accepts the payment request algorithm</dfn>
            are defined by the
            Payment Request API specification [[!PAYMENT-REQUEST-API]].</dd>
        <!--
        <dt>Payment Method Identifiers</dt>
        <dd>The terms <dfn data-lt="payment method|payment methods">payment method</dfn> and
            <dfn data-lt="payment method identifier|payment method identifiers">payment
            method identifier</dfn> are defined by the Payment Method
            Identifiers specification [[!METHOD-IDENTIFIERS]].</dd>
        -->
        <dt>HTML5</dt>
        <dd>The terms <dfn>global object</dfn>,<dfn>origin</dfn>, <dfn>queue a task</dfn>,
            <dfn>browsing context</dfn>, <dfn>top-level browsing
                context</dfn>, <dfn>structured clone</dfn>,
                <dfn>event handler</dfn>, <dfn>event handler event type</dfn>,
                <dfn>trusted event</dfn>,
                and <dfn>current settings object</dfn> are defined by
                [[!HTML5]].</dd>
            <dt>ECMA-262 6th Edition, The ECMAScript 2015 Language
                Specification</dt>
            <dd>The term <dfn>Promise</dfn>

        <!--
            , <dfn>internal slot</dfn>,
                <dfn><code>TypeError</code></dfn>, <dfn>JSON.stringify</dfn>,
                <dfn>JSON.parse</dfn>, <dfn><code>Array</code></dfn>,
                <dfn><code>type</code></dfn> and the <dfn>[[\GetOwnProperty]]</dfn>
                operation are
        -->
                is defined by [[!ECMA-262-2015]].
        <!--
                <p>This document uses the format <em>object</em>@[[\slotname]] to
                    mean the internal slot [[\slotname]] of the object
                    <em>object</em>.</p>
                <p>The term <dfn>JSON-serializable object</dfn> used in this
                    specification means an object that can be serialized to a string
                    using <a>JSON.stringify</a> and later deserialized back to an
                    object using <a>JSON.parse</a> with no loss of data.</p>
                <p>When instructed to <dfn>Trim</dfn>(<var>x</var>), a user agent
                    MUST behave as if [[!ECMA-262-2015]]'s
                    <code>String.prototype.trim()</code> function had been called on
                    the string <var>x</var>.</p>
        -->
            </dd>
            <dt>DOM4</dt>
            <dd>
            <!--
                The <code><dfn>Event</dfn></code> type and the terms <dfn>fire
                an event</dfn>, <dfn>dispatch flag</dfn>, <dfn>stop propagation
                flag</dfn>, and <dfn>stop immediate propagation flag</dfn> are
                defined by [[!DOM4]].
            -->
                <p><dfn>DOMException</dfn> and the following DOMException types
                    from [[!DOM4]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>AbortError</dfn></code></td>
                        <td>The operation was aborted</td>
                    </tr>
                    <tr>
                        <td><code><dfn>InvalidStateError</dfn></code></td>
                        <td>The object is in an invalid state</td>
                    </tr>
                    <!--
                    <tr>
                        <td><code><dfn>NotSupportedError</dfn></code></td>
                        <td>The payment method was not supported</td>
                    </tr>
                    -->
                    <tr>
                        <td><code><dfn>SecurityError</dfn></code></td>
                        <td>The operation is only supported in a secure context</td>
                    </tr>
                    <tr>
                        <td><code><dfn>OperationError</dfn></code></td>
                        <td>The operation failed for an operation-specific reason.</td>
                    </tr>
                </table>
            </dd>
            <dt>WebIDL</dt>
            <dd>
            <!--
                When this specification says to <dfn>throw</dfn> an error, the
                <a>user agent</a> must throw an error as described in [[!WEBIDL]].
                When this occurs in a sub-algorithm, this results in termination of
                execution of the sub-algorithm and all ancestor algorithms until
                one is reached that explicitly describes procedures for catching
                exceptions.
            -->
                <p>The following DOMException types from [[!WEBIDL]] are used:</p>
                <table>
                    <tr>
                        <th>Type</th>
                        <th>Message (optional)</th>
                    </tr>
                    <tr>
                        <td><code><dfn>NotAllowedError</dfn></code></td>
                        <td>The request is not allowed by the user agent or the
                        platform in the current context.</td>
                    </tr>
                </table>
                </dd>
        <dt>Secure Contexts</dt>
        <dd>The terms <dfn>secure context</dfn> is defined by the Secure
          Contexts specification [[!POWERFUL-FEATURES]].</dd>
        <dt>URL</dt>
        <dd>The <dfn>URL</dfn> concept and <dfn>URL parser</dfn> are
            defined in [[!WHATWG-URL]].</dd>
        <dt>Fetch</dt>
        <dd>The terms <dfn>Fetch</dfn>, <dfn>Request</dfn>, <dfn data-lt="body">Request Body</dfn>, <dfn data-lt="method">Request
            Method</dfn>, <dfn>Header List</dfn>, <dfn>Response</dfn>,
            <dfn>Context</dfn> and <dfn>Network Error</dfn> are defined in
            [[!FETCH]].</dd>
        <dt>Service Workers</dt>
        <dd>The terms
          <dfn data-lt="service worker|service workers">service worker</dfn>
          <dfn>service worker registration</dfn>,
          <dfn>active worker</dfn>,
          <dfn>installing worker</dfn>,
          <dfn>waiting worker</dfn>,
          <dfn>handle functional event</dfn>,
          <dfn>extend lifetime promises</dfn>,
          and
          <dfn data-lt="scope url|scope urls">scope URL</dfn>
          are defined in [[SERVICE-WORKERS]].</dd>
    </dl>
</section>
<section id="model">
  <h2>Payment App Model and Design Considerations</h2>
  <p>This section (which may be temporary) intends to help build shared understanding of the capabilities and limitations of the specified model.</p>
  <section>
    <h3>General Considerations</h3>
    <ul>
      <li>This specification builds on PaymentRequest API.</li>
      <li>It defines mechanisms that may be used to support both Web-based and <a>native payment apps</a>. However, we anticipate
          that the ecosystem will also include proprietary approaches to some of the functionality defined here
          (e.g., for payment app registration or invocation).</li>
    </ul>
  </section>
  <section>
    <h3>Decoupling and Trust</h3>
    <ul>
<li>    A goal of this system is to decouple the payment methods used to pay from the software (payment apps) that implement those payment methods. By decoupling, merchants (and their payment service providers) can lower the cost of creating a checkout experience, users can have more choice in the software they use to pay, and payment app providers can innovate without imposing an integration burden on merchants.</li>
<li>User choice of payment apps that support a given payment method will depend in part on the willingness of the payment method owner to license implementations (e.g., via a manifest other mechanism). For example, there may only be one app authorized to support a payment method owned by a company, while there may be many apps that support basic credit card payments or credit transfers.</li>
<li>    For privacy, the design should limit information about the user's environment available to merchant without user consent. That includes which payment apps the user has registered. The merchant should not receive information about which payment app the user selected to pay unless the user consents to share that information; of course when there is only one payment app for a given payment method that information is already publicly known. See <a href="https://github.com/w3c/browser-payment-api/issues/224">issue 224</a> for discussion about how merchant may track progress of a push payment.</li>
<li>    Although decoupling relieves merchants of implementing some aspects of the checkout experience, one consequence is that they give up some degree of control. This was already the case for some payment methods, but for traditional card payments, merchants (or their PSPs) will be entrusting some portion of data collection to the browser or third party payment apps.</li>
<li>The design therefore includes support for merchants to recommend payment apps and suggest the ordering of payment methods. The design should endeavor not to constrain how user agents make use of this information, only provide guidance to user agent makers about taking into account both merchant and user preferences.</li>
<li>Here are preferences the system might support:
  <ul>
<li>        Accepted payment methods (payment methods the merchant accepts, and no others may be used; part of payment request API)</li>
<li>        Preferred payment methods (payee-specified order part of payment request API)</li>
<li>        Recommended payment apps (payment apps the merchant prefers, but others may be used)</li>
  </ul>
</li>
<li> The user agent can use this information in conjunction with user preferences to:
  <ul>
    <li>   Filter payment apps (to matching payment methods)</li>
<li>        Order payment apps (according to merchant specified order)</li>
<li>        Display recommended payment apps (according to merchant-recommended payment app order)</li>
    </ul>
</li>
</ul>
  </section>
  <section>
    <h3>Registration and Unregistration</h3>
    <ul>
      <li>Registration provides a way for user agents
	to remain aware of the user's payment apps across transactions.</li>
      <li>Registration is not a
	prerequisite for using a payment app. In particular, a user
	should be able to pay with a merchant-recommended payment app
	that the user has not yet registered. Note: this implies
	that payment apps (at least in some cases) should be designed
	to process requests without assuming prior registration.
	There may also be security implications (since we expect to
	rely on origin information as a security mechanism at registration).</li>
      <li>The payee should provide all data necessary to display and invoke a
        recommended payment app in the payment request. Invocation of a payment
        app that is not registered can use the same mechanism as a registered
        payment app except all data should be considered ephemeral and the user
        agent does not remember the app.</li>
      <li>When registration is desired it might happen in a variety of ways:
	<ul>
	  <li>This working group will define an API available for all types of payment apps.</li>
	  <li>Native apps and user agents may have platform-specific ways to achieve the same (or similar) result.</li>
	</ul>
      </li>
      <li>We expect registrations to happen at various times (e.g., outside and inside of checkout), and with differing levels of
          user consent to modify their configuration within the user agent. In general, explicit consent should not be required
          while the user is within the context of the payment request UI. Here are some examples:
        <ul>
          <li>When the merchant recommends a payment app and the user selects it, registration can happen in that moment without
              additional user action or consent. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/34#issuecomment-245431139">notes from Rouslan</a> on registration upon selection of recommended payment app.</li>
          <li>When browser recommends a payment app and the user selects it, registration can happen in that moment without additional user action or consent.</li>
          <li>When the user installs native payment app, registration could happen either through platform-specific mechanisms (or through this standard API) without additional user action beyond installation.</li>
          <li>Users visiting a Web site (e.g., merchant or bank) may wish to explicitly register payment apps, which would require explicit
              consent from the user. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/34#issuecomment-245431139">notes from Rouslan</a> on gating registration on user activation.</li>
        </ul>
      </li>
      <li>During registration as defined in this specification, information about enabled payment methods and display details of the payment app is provided to the user agent.
          The user agent stores this information for subsequent actions (e.g., when matching payee-accepted payment methods). In this
          proposal, there are no requirements for a payment app to be able to respond to user agent queries for updated
          registration information. In this proposal, payment apps update the information that a user agent has stored about them
          by re-calling the registration API. (See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/36">issue 36</a>.)</li>
      <li>We expect user agents to distinguish themselves in how they balance different ease of registration and security.</li>
      <li>It is important for merchants and users to be able to trust the
	authenticity of payment apps. A starting point is to rely on origin information (e.g., if a payment app is registered on a Web site). In contexts where origin binding is not available (e.g., native payment apps) other mechanisms should be considered to help establish authenticity (e.g., origin-bound confirmation of a digital signature of a native payment app).</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Identification</h3>
    <ul>
<li>    For recommended payment apps we will need <a>payment app identifiers</a> (PAIs). See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/35#issuecomment-245747771">discussion around issue 35</a>.</li>
<li>    A PAI should include origin information. This origin information may be used in a variety of ways:
  <ul>
<li>        The origin information could enable user agents to provide the user with useful services when the user is browsing a site with the same origin (e.g., putting that payment app at the top of a list or otherwise highlighted).</li>
<li>        For a payment method with an associated origin, the user agent can do some (security) checks by comparing the origin of the payment method and any authorized payment app.</li>
  </ul>
<li>    A PAI should allow for granularity (e.g., payment app versioning) in the form of constrained URLs. <strong>Note:</strong> The Working Group is discussing a constrained syntax for payment method identifiers (e.g., origin, case-sensitive path, no trailing slash) and we should consider aligning with that preference.</li>
</ul>
  </section>
  <section>
    <h3>Payment App Matching</h3>
    <ul>
      <li>When the user invokes the Payment Request API (e.g., by "pushing the Buy button"), the user agent
          computes the intersection between payee-accepted payment methods and user-registered payment methods. It
          does this by comparing Payment Request API data (from the payee) and data provided during registration,
          invoking the comparison algorithm defined in
          [[!METHOD-IDENTIFIERS]]. The result is a list of
          matching payment apps and recommended payment apps.</li>
      <li>Using information provided during registration (e.g., an app name or icon),the user agent displays matching
          payment apps for selection by the user. The user agent may also display merchant-recommended and user-agent-recommended payment apps, which are
          displayed distinctly for the user. This mechanism is intended to support use cases such as a merchant
          recommending their own payment app or one they trust to the user.
	<p class="note" title="User Agent selection features not in scope">The user agent may offer features to facilitate selection (e.g., launch a chosen payment app every time the user wants to pay at a given Web site); those features lie outside the scope of this specification.</p></li>
      <li>The user selects a payment app to make a payment. The user may also select a recommended payment app.</li>
    </ul>
  </section>
  <section>
    <h3>User Experience</h3>
    <ul>
      <li>The system should minimize user interaction for payment app registration, payment app selection, and payment credentials selection. Ideas include:
	<ul>
	  <li>When only one payment app matches, the user agent does not require user selection to launch it.</li>
	  <li>The user agent displays payment options for direct selection by the user. For example, instead of merely displaying information about a payment app that supports cards, the user agent could display some representation of individual registered cards. If the user can select an option directly, that could contribute to reducing the total number of required user actions. </li>
	</ul>
      </li>
      <li>It is likely that this specification will include <em>guidance</em> rather than requirements about specific user experience optimizations.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Invocation and Response</h3>
    <ul>
      <li>Based on information provided at registration, the user agent "launches" the payment app and provides it with
        input data drawn from the Payment Request API. </li>
      <li>The user may interact with the payment app in a variety of ways to authorize payment, cancel the transaction,
          or carry out other activities supported by the payment app. This specification does not address payment app
          behavior other than accepting requests and returning responses to the user agent.</li>
      <li>This specification defines a means for the user agent to receive a response asynchronously once the user has
          authorized payment. The response becomes the response of the Payment Request API.</li>
    </ul>
  </section>
  <section>
    <h3>Network Considerations</h3>
    <ul>
      <li>This specification only describes communication between the
          user agent and the payment app. This includes an
          asynchronous mechanism for a payment app to return a payment
          response to the user agent. This specification does not
          (yet) address scenarios where the user agent does not
          receive the response (e.g., due to a crash or network
        outage). Network failure may be especially problematic in the
	case of a push payment; see <a href="https://github.com/w3c/browser-payment-api/issues/224">issue 224</a>, and so the Working Group is considering whether the specification should include a standard way to learn how to query a component for payment state information. For example, many systems use backchannel communications, so one idea is for the payee to provide a callback URL. This would allow (but not require) the payment app to communicate with the payee server until such time as all parties are satisfied they share the same view of the payment response. An alternative would be to provide the payment app and the user agent a channel so that communication continues until all parties are satisfied they share the same view of the payment response. This might involve caching payment responses.</li>
      <li>This specification does not address communication between the payee server and the payee Web app, or between
          the payment app and other parties (e.g., the payment app distributor, or directly to the merchant).</li>
    </ul>
  </section>
</section>
<section id="definitions">
  <h2>Definitions</h2>
  <div data-include="https://w3c.github.io/webpayments-ig/latest/common/terms.html"
       data-oninclude="restrictReferences">
  </div>

  <section>
  <h3>Payment App Implementation Technology</h3>
  <dl>
    <dt><dfn id="dfn-user-agent-based-payment-app"
         data-lt="user-agent-based payment app|user-agent-based payment apps">
    user agent-based payment app</dfn></dt>
    <dd>a <a>payment app</a> that runs in a <a>user agent</a>. User agent-based
    payment apps may elect to display a user interface, or to operate without
    any user interaction. This decision is made at runtime, and may vary based
    on criteria of the app's choosing (such as how long it has been since the
    user last authenticated themselves).</dd>

    <dt><dfn id="dfn-native-payment-app" data-lt="native payment app|native payment apps">native payment app</dfn></dt>
    <dd>a payment app built with the operating system default technology stack that uses non-Web technologies.</dd>
    <dt><dfn id="dfn-native-payment-app">ignored payment app</dfn></dt>
    <dd class="issue">An app that the user has configured to not be displayed, or that the user agent ignores for security reasons.</dd>
    <dt><dfn id="dfn-payment-app-identifier"
         data-lt="payment app identifier|payment app identifiers">
    payment app identifier</dfn></dt>
    <dd>
       A unique identifier for a <a>payment app</a> (e.g., from a <a>payment
       method</a> manifest file). This specification defines these identifiers
       as to be <a>service worker</a> <a>scope URLs</a>. As such, they are not
       expected to be dereferenced.
    </dd>
    <dt><dfn>payment app window</dfn></dt>
    <dd>
      A <a>service worker</a> <code>WindowClient</code> used by <a>user agent-based
      payment apps</a> to interact with the user when doing so is necessary to
      complete the payment transaction.
    </dd>
  </dl>
  <p class="note" title="Payment Apps in scope">
    The Web Payments Working Group intends for this specification to apply to any payment app that may be invoked by the user agent, whatever technologies have been used to implement the payment app.</p>
  </section>
  <section>
  <h3>Payment App Registration States</h3>
  <dl>
      <dt><dfn id="dfn-registered-payment-app">registered payment app</dfn></dt>
      <dd>a payment app that is "known" to the user agent for the purposes of the interactions described in this document.

      <div class="note" title="Platform-specific registration">
          This specification defines a registration mechanism. Other registration mechanisms might co-exist with this one
          (e.g., on some platforms there may be a way to register a payment app directly with the operating system).</div>
      </dd>
      <dt><dfn id="dfn-unregistered-payment-app">unregistered payment app</dfn></dt>
      <dd>a payment app that is not known to the user agent, either because it has never been registered, or because it has been unregistered.</dd>

	  <dt><dfn id="dfn-enabled-payment-app">enabled payment app</dfn></dt>
	  <dd>A <a>registered payment app</a> with at least one <a>enabled
	      payment method</a>.</dd>
  </dl>
  </section>
  <section>
  <h3>Payment App Selection States</h3>
  <dl>
    <dt><dfn id="dfn-matching-payment-app">matching payment app</dfn></dt>
    <dd>An <a>enabled payment app</a> that:
      <ul>
	<li>has at least one <a>enabled payment method</a> that the
	  <a>payee</a> accepts.</li>

	<li>is not an <a>ignored payment app</a>.</li>
      </ul>
    </dd>
      <dt><dfn id="dfn-recommended-payment-app">recommended payment app</dfn></dt>
      <dd>a payment app suggested by the payee or user agent that may be used to handle a specific payment request.
          <p class="issue" data-number="112" title="Recommended Payment Apps is still under discussion">
              The Working Group has not yet agreed that the system should support recommended payment apps.
              Inclusion might involve small changes to payment request API. 
      </dd>
      <dt><dfn id="dfn-displayed-payment-app">displayed payment app</dfn></dt>
	  <dd>A <a>matching payment app</a> or <a>recommended payment app</a> with at least one matching payment method (i.e., presented by the user agent for user selection).</dd>
      <dt><dfn id="dfn-selected-payment-app">selected payment app</dfn></dt>
      <dd>the payment app selected by the user to make a payment, but not yet invoked.</dd>

      <dt><dfn id="dfn-invoked-payment-app">invoked payment app</dfn></dt>
      <dd>the <a>selected payment app</a> that the user agent has invoked (executed) and passed payment app input data.</dd>
  </dl>

  </section>
  <section>
  <h3>Payment Method Support</h3>
  <dl>
      <dt><dfn id="dfn-supported-payment-method">supported payment method</dfn></dt>
      <dd>a payment method that a payment app has been designed to support. This payment method may or may
          not currently be enabled. A payment app MAY support more than one payment method.</dd>

      <dt><dfn id="dfn-unsupported-method">unsupported payment method</dfn></dt>
      <dd>a payment method that cannot be enabled by a payment app. Updates to a payment app may cause an
          unsupported payment method to become supported, or vice-versa.</dd>

      <dt><dfn id="dfn-enabled-method">enabled payment method</dfn></dt>
      <dd>a supported payment method that a registered payment app is able to handle. The payment app must have at least
          one enabled payment method.
      <p class="note" title="Supported vs enabled Payment Methods">
          The difference between <strong>supported</strong> and <strong>enabled</strong> payment methods is one of design-time vs runtime consideration.
          A payment app supports all the payment methods it was designed to support; however at runtime only a subset
          may be enabled due to configuration or other runtime requirements that may not have been met for all
          supported payment methods.
      </p>
</dd>

  </dl>
  </section>
  <section>
  <h3>Payment App Invocation and Response Data</h3>
  <dl>
    <dt><dfn id="dfn-app-request-data">payment app request data</dfn></dt>
    <dd>data provided to the invoked payment app by the user agent to initiate a payment request. This data is a subset
        of data input to the Payment Request API.
    <p class="note" title="JSON serialization">
        The data passed between the user agent and the payment app will be serialized as JSON data.
    </p>
    </dd>
    <dt><dfn id="dfn-app-response-data">payment app response data</dfn></dt>
    <dd>data returned by an invoked payment app to the user agent, typically after payment authorization or other action
        taken through the payment app. This data, which will vary according to payment method, is then returned to the payee via
        the Payment Request API as part of the payment response.</dd>
  </dl>
</section>
</section>
<section id="overview">
  <h2>Overview of Service-Worker-Based Approach</h2>

<p>In this specification we use <a>service workers</a>
    to connect user agents with user agent-based payment apps. We do so for
    several reasons:</p>

    <ul>
      <li>
        Service workers provide a cleanly isolated execution context that allows
        the <a>payment app</a> to run with clean separation from the
        <a>payee</a> website.
      </li>
      <li>We can leverage the ways in which service workers already
          handle lifecycle management (registration, update, and removal of
          <a>payment apps</a>), enable offline use, etc.</li>
      <li>We can leverage service worker origins for security, especially
          when used in conjunction with origins associated with <a>payment
          method identifiers</a>.</li>
    </ul>

<p class="note">
  The use of service workers restricts <a>user agent-based payment apps</a> so
  that they must run only in secure contexts. The introduction of this
  restriction is deliberate, due to the sensitivity of the role that payment
  apps play. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/24">issue 24</a> for information about launching the payment app in a secure context.
</p>

<p>Here is the flow envisioned by this document:</p>
  <ol>
    <li>Through registration, a <a>service worker</a> is created and
        associated with <a>payment methods</a>
        (and associated metadata).</li>
    <li>When the <code>payment request API</code> is called, the user agent
        displays a list of registered service workers associated
        with matching payment methods (along with any other payment apps
        that may be available to the user agent).</li>
    <lI>When the user selects a <a>user agent-based payment
        app</a>, the corresponding <a>service worker</a> is activated, and
        it receives a <a>PaymentRequestEvent</a>.</li>
    <li>Once active, the <a>payment app</a> performs whatever steps are
        necessary to authenticate the user, process the payment, and return
        payment information to the <a>payee</a>. If interaction with the user
        is necessary, the <a>payment app</a> can open a <a>payment app
        window</a> for that purpose.</li>
    <li>Finally, once the <a>payment app</a> is finished with its processing, it
        resolves a <a>Promise</a> passed to it in the event. This causes the
        <code>Promise&lt;PaymentResponse&gt;</code> returned from
        <code>PaymentRequest.show()</code> to resolve.</li>
  </ol>
</section>
<section id="registration">
    <h2>
      Payment App Registration
    </h2>
    <section>
    <h3>
      Extensions to the <a>ServiceWorkerRegistration</a> interface
    </h3>
      <p>
        The Service Worker specification defines a <code>ServiceWorkerRegistration</code> interface
        [[!SERVICE-WORKERS]], which this specification extends.
      </p>
      <pre id="service-worker-registration-idl" class="idl">
        partial interface ServiceWorkerRegistration {
          readonly attribute PaymentAppManager paymentAppManager;
        };
      </pre>
  </section>
  <section id="payment-app-manager">
  <h2>
    <a>PaymentAppManager</a> interface
  </h2>
      <pre id="payment-app-manager-idl" class="idl">
      interface PaymentAppManager {
        Promise&lt;void&gt; setManifest(PaymentAppManifest manifest);
        Promise&lt;PaymentAppManifest&gt; getManifest ();
      };
      </pre>
      <section id="set-manifest">
      <h3>
        PaymentAppManager.setManifest()
      </h3>
        <p>
            The <code><dfn>setManifest</dfn></code> method is used to enable a
            service worker to process <a>payment requests</a>, and to set the
            properties associated with the <a>payment app</a>.
        </p>
        <p>The following algorithm provides an <dfn>extension point</dfn>: other
        specifications that add new members to the manifest are encouraged to
        hook themselves into this specification at this point in the
        algorithm.</p>
        <p>The <code>setManifest</code> method, when invoked,
        MUST run the following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            <a>Extension point</a>: if the user agent has custom steps to invoke
            when registering payment apps, execute these steps (possibly
            rejecting <var>promise</var> with a <code><a>DOMException</a></code>
            whose name is "<code><a>OperationError</a></code>") and terminate
            these steps.
            <div class="note">
              Through this <a>extension point</a> we seek to avoid
              <a href="https://annevankesteren.nl/2014/02/monkey-patch">issues
                related to monkey patching</a>.
            </div>
          </li>
          <li>
            Let <var>manifest</var> be the value of the <code>manifest</code>
            argument.
          </li>
          <li>
            If <var>manifest</var>.<code>canHandle</code> is present but is
            not set to an executable function, reject <var>promise</var> with
            a <code><a>DOMException</a></code> whose name is
             "<code><a>OperationError</a></code>" and terminate these steps.
          </li>
          <li>
            Let <var>registration</var> be the
            <code><a>PaymentAppManager</a></code>'s associated <a>service
            worker registration</a>.
          </li>
          <li>If <var>registration</var> has no <a>active worker</a>, run the following substeps:
            <ol>
              <li>If <var>registration</var> has no <a>installing worker</a> and no <a>waiting
              worker</a>, reject <var>promise</var> with a <code><a>DOMException</a></code> whose
              name is "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Wait for the <a>installing worker</a> or <a>waiting worker</a> of
              <var>registration</var> to become its <a>active worker</a>.
              </li>
              <li>If <var>registration</var> fails to activate either worker, reject
              <var>promise</var> with a <code><a>DOMException</a></code> whose name is
              "<code><a>InvalidStateError</a></code>" and terminate these steps.
              </li>
              <li>Once <var>registration</var> has an <a>active worker</a>, proceed with the steps
              below.
              </li>
            </ol>
          </li>
          <li>
            Let <var>paymentMethods</var> be a list of URLs from <var>manifest</var> section
            on supported payment methods. Ensure that the payment app is licensed to claim support for the payment methods (e.g., they are explicitly authorized, or the payment method imposes no constraints). Otherwise, reject with a <code><a>DOMException</a></code> whose
            name is "<code><a>NotAllowedError</a></code>" and terminate these steps.
          </li>
          <li>
            Ask the user whether they allow the <a>payment app</a> to be
            registered to handle the indicated <a>payment methods</a>
            (unless a prearranged trust relationship applies or the user has
            already granted or denied permission explicitly for this <a>payment
            app</a>).
          </li>
          <li>
            If permission is not granted, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>NotAllowedError</a></code>" and terminate these steps.
          </li>
          <li>
            Register the <a>payment app</a> with the user agent for future use,
            associating <var>manifest</var>'s <code>name</code> and
            <code>icons</code> set with the payment app for user reference.
          </li>
          <li>
            For each <a>PaymentAppOption</a> present in the
            <code>options</code> field of the <var>manifest</var>:
            <ol>
              <li>
                Add a new payment option to the <a>payment app</a>'s
                registration, associating it with the <a>PaymentAppOption</a>
                <code>name</code> and <code>icons</code> fields.
              </li>
              <li>
                For each <a>payment method</a> indicated in the
                <a>PaymentAppOption</a>'s <code>enabledMethods</code>
                field, associate the payment option and the <a>payment app</a>
                with the payment method.
              </li>
            </ol>
          </li>
          <li>
            Resolve <em>promise</em> with <code>undefined</code>.
          </li>
        </ol>
      </section>
      <section id="get-manifest">
      <h3>
        PaymentAppManager.getManifest()
      </h3>
        <p>
            The <code><dfn>getManifest</dfn></code> method is used to
            retrieve the properties associated with a registered
            <a>payment app</a>.
        </p>
        <p>The <code>getManifest</code> method, when invoked, MUST run the
        following steps or their equivalent:
        <ol>
          <li>
            Let <em>promise</em> be a new <a>Promise</a>.
          </li>
          <li>
            Return <em>promise</em> and asynchronously perform the remaining
            steps.
          </li>
          <li>
            If the <a>current settings object</a> is not a <a>secure
            context</a>, reject <var>promise</var> with a
            <code><a>DOMException</a></code> whose name is
            "<code><a>SecurityError</a></code>" and terminate these steps.
          </li>
          <li>
            If there is no <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>, reject <var>promise</var> with a
            <a>DOMException</a> whose name is "<code><a>AbortError</a></code>"
            and terminate these steps.
          </li>
          <li>
            Retrieve the <a>PaymentAppManifest</a> associated with the
            <a>Service Worker</a>.
          </li>
          <li>
            Let <var>manifest</var> be the retrieved <a>PaymentAppManifest</a>.
          </li>
          <li>
            Resolve <em>promise</em> with <var>manifest</var>.
          </li>
        </ol>
      </section>
  </section>
  <section id="payment-app-manifest">
  <h2>
    <a>PaymentAppManifest</a> interface
  </h2>
  <p class="issue"><a href="https://github.com/w3c/webpayments-payment-apps-api/issues/69">Issue 69</a>: The Payment Apps Task Force has a goal of alignment with the draft <a href="https://github.com/w3c/manifest">Web App Manifest</a> specification for data used to display payment app and options for selection by the user. More work is necessary to determine whether the Payment App API should reference (part of) the Web App Manifest specification, import definitions while that specification remains a draft, or define new terms.</p>
      <pre id="payment-app-manifest-idl" class="idl">
      dictionary AvailableOption {
        required DOMString id;
        short modifier;
      };

      callback CanHandleCallback = Sequence&lt;AvailableOption&gt;
      (sequence&lt;PaymentMethodData&gt; methodData, PaymentDetails details);

      dictionary PaymentAppManifest {
        required DOMString name;
        sequence&lt;ImageObject&gt; icons;
        required sequence&lt;PaymentAppOption&gt; options;
        CanHandleCallback canHandle;
      };
      </pre>
        <dl>
            <dt><code>name</code> member</dt>
            <dd>
                The <code>name</code> member is a string that represents the
                label for this <a>payment app</a> as it is usually displayed
                to the user.
            </dd>
            <dt><code>icons</code> member</dt>
            <dd>
                The <code>icons</code> member is an array of image objects that can serve as iconic representations of the <a>payment app</a> when presented to the user for selection.
            </dd>
            <dt><code>options</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-manifest-options"><code>options</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option.
            </dd>
            <dd class="issue">
                <p>Options are an extra layer of abstraction, because they allow
                  flattening of payment apps. The flattening may result in unique
                  UX challenges. For example, if two payment apps both have
                  "<em>Visa ending in ***4756</em>" payment option, then users may
                  be confused when they see two such labels in UI. One solution
                  is to prepend the payment app name, e.g., "<em>ExampleApp Visa
                  ending in ***4756</em>". However, when only one app is
                  installed, the text "<em>ExampleApp</em>" is redundant.</p>
            </dd>
            <dt><code>canHandle</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-manifest-canhandle"><code>canHandle</code></dfn>
                member indicates a function that is responsible for determining
                whether the <a>payment app</a> being registered is capable of
                handling a given request. If this member is not included in the
                manifest, the payment app is expected to be capable of
                handling all requests for the indicated <a>payment method
                identifiers</a>. <a>canHandle</a> runs with a globally unique
                origin, and is not allowed network access. The return value from
                <a>canHandle</a> is a sequence of zero or more
                <code>HandledOptions</code> dictionaries. Each dictionary
                represents a <code>PaymentAppOption</code> that can handle
                the request. The mandatory <code>AvailableOption.id</code>
                member corresponds to the <code>PaymentAppOption.id</code> for
                the <code>PaymentOption</code> corresponding to the dictionary.
                If present, the <code>AvailableOption.modifier</code> member is
                an index into the <code>PaymentRequest.modifiers</code>
                sequence, indicating which modifer applies to the corresponding
                <code>PaymentAppOption</code>.
            </dd>
        </dl>
  </section>
  <section id="payment-app-options">
  <h2>
    <a>PaymentAppOption</a> dictionary
  </h2>
      <pre id="payment-app-options-idl" class="idl">
      dictionary PaymentAppOption {
        required DOMString name;
        sequence&lt;ImageObjects&gt; icons;
        required DOMString id;
        sequence&lt;DOMString&gt; enabledMethods;
      };
      </pre>
      <dl>
	<dt><code>name</code> member</dt>
        <dd>
          The <code>name</code> member is a string that represents the
                label for this <a>payment app</a> as it is usually displayed
                to the user.
            </dd>
            <dt><code>icons</code> member</dt>
            <dd>
                The <code>icons</code> member is an array of image objects that can serve as iconic representations of the <a>payment app</a> when presented to the user for selection.
            </dd>

            <dt><code>id</code> member</dt>
            <dd>
                The <code>id</code> member is an identifier, unique
                within the <a>PaymentAppManifest</a>, that will be passed to the
                payment app to indicate the <a>PaymentAppOption</a> selected
                by the user.
            </dd>
            <dt><code>enabledMethods</code> member</dt>
            <dd>
                The <dfn
                id="payment-app-option-enabled-methods"><code>enabledMethods</code></dfn>
                member lists the <a>payment method identifiers</a> of the
                payment methods enabled by this option. <span class="issue">When the merchant has provided a filter, it may be necessary to provide <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/63#issuecomment-264283996">additional information</a> about conditions under which the payment method is enabled. 
            </dd>
        </dl>
  </section>
  <section id="payment-app-manifest-location">
    <h3>
      Payment App Manifest Location
    </h3>
      <p>Aside from <code>ServiceWorker</code> registration, it's useful for user agents to
      download the <a>payment app manifest</a> from a well-defined location. This allows merchants to recommend payment apps via the payment app identifier.</p>
      <div class="issue">
        How to map payment app URL to the location of the manifest file? For example, how
        to map <code>https://bobpay.com</code> to
        <code>https://bobpay.com/payment-manifest.json</code>?
      </div>
  </section>
  <section id="register-example">
  <h3>
    Registration Example
  </h3>
    <p>The following example shows how to register a <a>user agent-based payment
    app</a>:</p>
       <pre class="example highlight" title="Payment App Registration">
         navigator.serviceWorker.register('/exampleapp.js')
         .then(function(registration) {
           return registration.paymentAppManager.setManifest({
             name: "ExampleApp",
             icons: [
                {
                  "src": "icon/lowres.webp",
                  "sizes": "48x48",
                  "type": "image/webp"
                },{
                  "src": "icon/lowres",
                  "sizes": "48x48"
                } ]
             options: [
               {
                 name: "Visa ending ****4756",
                 id: "dc2de27a-ca5e-4fbd-883e-b6ded6c69d4f",
                 enabledMethods: ["basic-card"]
               },
               {
                 name: "My Bob Pay Account: john@example.com",
                 id: "c8126178-3bba-4d09-8f00-0771bcfd3b11",
                 enabledMethods: ["https://bobpay.com/"]
               },
               {
                 name: "Add new credit/debit card to ExampleApp",
                 id: "new-card",
                 enabledMethods: ["basic-card"]
               }
             ],
             canHandle: function (methodData, details) {
               // TODO: Code here to return mapping from payment option IDs
               // to methodData option indices.
             }
           });
         }).then(function() {
           console.log("Installed payment app from /paymentapp.js"); // Success!
         }).catch(function(error) {
           console.log(error);
         });
     </pre>
     <p class="issue" title="Payment method identifiers">
       The Editors will update the payment method identifier syntax in this
       and other examples to align with [[!METHOD-IDENTIFIERS]], once a final
       format has been agreed upon.
     </p>
  </section>

  <section id="native-app-registration">
  <h3>
    Native App Registration
  </h3>
  <p>
    Information required for payment apps should be present in the <a>payment
    app manifest</a> under an <a>extension point</a>. For example,
    information for Android native payment apps may live under
    <code>"android"</code> section of the app manifest. This specification does
    not define the contents of native app descriptions. This is defined
    elsewhere.
  </p>
  <p class="issue" title="Registration of native payment apps?">
      What else, if anything, should we say about registering <a>native payment
      apps</a>?
  </p>
  <p class="note" title="Origin for native apps">
    <a>Native payment apps</a> on some platforms (e.g., on Android) can claim
    ownership of their origins. To verify origin ownership, user agents need to
    perform extra steps that are not defined in this specification.
  </p>
  </section>
</section>
<section id="matching">
  <h2>Payment App Matching</h2>
  <div class="issue" title="Dependency on Payment Method Identifiers spec">
      <p>
          We anticipate that [[!METHOD-IDENTIFIERS]] will define the PMI matching algorithm. This
          specification will explain how to invoke that algorithm using data available from the Payment Request API input
          and payment method information aggregated from:
      </p>
      <ul>
          <li>enabled payment methods across all registered payment apps.</li>
          <li>supported payment methods of recommended but unregistered payment apps.</li>
      </ul>
      <p>The Working Group should discuss:</p>
      <ul>
	<li>How matching takes place for payment-method specific filtering. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/63">issue 63</a></li>
	<li>Good practice around making it easy for users to use trusted apps (e.g., white listing by the browser or merchant) and hard to use risky apps (e.g., warnings to the user and explicit user overrides as done today with untrusted certificates).</li>
      </ul>
  </div>
  <p>
    When the <a>mediator</a> calculates <i>acceptedMethods</i> during the
    process of running the steps for the <code>PaymentRequest.show()</code>
    method, the means of determining whether a registered <a>payment app</a>
    should be made available for user selection is computed by
    performing the following steps:
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Set <var>requestMethods</var> to a set containing the values
          in the <code>supportedMethods</code> value of the
          <code>PaymentMethodData</code> from the <code>PaymentRequest</code>
          on which <code>show()</code> has been called.
        </li>
        <li>
          For each <var>paymentDetailsModifier</var> in
          <code>details.modifiers</code> in the
          <code>PaymentDetails</code> from the <code>PaymentRequest</code>
          on which <code>show()</code> has been called, add all entries in
          <var>paymentDteailsModifier</var>.<code>supportedMethods</code> to
          <var>requestMethods</var>.
        </li>
        <li>
          Set <var>commonMethods</var> to the set union of
          <var>paymentMethods</var> and <var>requestMethods</var>.
        </li>
        <li>
          If <var>commonMethods</var> is a null set, this <a>payment app</a> is
          not considered to be a candidate to handle the
          <code>PaymentRequest</code> and terminate these steps.
        </li>
        <li>
          If the <code>PaymentAppManifest</code> does not contain a
          <code>canHandle</code> attribute, then this <a>payment app</a> is a
          candidate for handling the <code>PaymentRequest</code>. Only those
          <a>PaymentAppOption</a>s that have <code>enabledMethods</code>
          containing at least one member of <var>commonMethods</var> are to be
          displayed to the user. Terminate these steps.
        </li>
        <li>
          Set <var>methodDataCopy</var> to a deep copy of the
          <code>methodData</code> parameter of the <code>PaymentRequest</code>.
        </li>
        <li>
          Set <var>detailsCopy</var> to a deep copy of the
          <code>details</code> parameter of the <code>PaymentRequest</code>.
        </li>
        <li>
          Create an isolated interpreted context, a JavaScript realm that
          operates with a globally unique origin. Access to the network must be
          disallowed from within this context.
        </li>
        <li>
          Populate the realm with a single global function,
          <var>canHandle</var>, set to the value of
          <code>PaymentAppManifest.canHandle</code>.
        </li>
        <li>
          Execute <var>canHandle</var> in the realm, passing
          <var>methodDataCopy</var> and <var>detailsCopy</var> as the parameters
          to the function. Set <var>returnValue</var> to the return value of
          the function.
        </li>
        <li>
          If the execution of <var>canHandle</var> results in an exception or
          <var>returnValue</var> is not a <code>Sequence</code> of
          <code>AvailableOption</code>s, then this
          <a>payment app</a> is not considered to be a candidate to handle the
          <code>PaymentRequest</code>. Terminate these steps.
        </li>
        <li>
          For each <code>AvailableOption</code> of <var>returnValue</var>,
          verify that the value of its <code>modifier</code> entry, if
          present, is an integer, no smaller than 0, and no larger than the
          largest index of <code>PaymentRequest.modifiers</code> sequence. Any
          <code>AvailableOption</code> that fails this validation is removed
          from the sequence.
        </li>
        <li>
          If <var>returnValue</var> has no remaining
          <code>AvailableOption</code>s, then this
          <a>payment app</a> is not considered to be a candidate to handle the
          <code>PaymentRequest</code>. Terminate these steps.
        </li>
        <li>
          If processing has reached this point, then the <a>payment app</a> is
          a candidate for processing the <code>PaymentRequest</code>. Each
          <code>AvailableOption</code>
          in <var>returnValue</var> corresponds to a matching
          <code>PaymentAppOption</code> that can service the request. If present
          the <code>PaymentAppOption.modifier</code> indicates which
          <code>PaymentDetailsModifier</code> will be applied by the
          corresponding <code>PaymentAppOption</code>.
        </li>
      </ol>
  </p>
</section>
<section id="selection">
  <h2>Payment App Selection</h2>
  <section>
    <h3>Selectable App Information Display</h3>
    <p class="issue" title="Need to define display algorithm">
        After matching the user agent will have a list of payment apps that the user can select to handle the
        payment request. How will these are displayed and ordered, where do recommended apps
        fit in to the order and how do we treat apps that are both registered and recommended?
    </p>
    <p class="issue" title="Should payment instrument details be included?" data-number="12">
        What information is needed by the user agent to display selectable apps? This needs to be captured during registration.
    </p>
    <p>
      The output of the payment method matching algorithm will be a list of matching payment apps and options from registered
      payment apps, and a list of recommended payment apps. The user agent will present this list of payment apps to the user for selection.
    </p>
    <p>For matching payment apps:</p>

    <ul>
      <li>The user agent <span class='rfc2119'>MUST</span> enable the user to select any matching payment app. <strong>Note:</strong> See the definition of matching payment app, which excludes payment apps ignored due to user configuration or security issues. Note also that the language here is about enabling selection rather than display &mdash; when the user agent displays only a subset of matching payment apps (e.g., the most recently used), the user must still be able to access other matching payment apps. </li>
      <li>The user agent <span class='rfc2119'>MUST</span> enable the user to select any matching <a href="#payment-app-options">payment app options</a>.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> favor user-side order preferences (based on user configuration or behavior) over payee-side order preferences.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> display matching payment apps in an order that corresponds to the order of supported payment methods provided by the payee, except where overridden by user-side order preferences.</li>
      <li>The user agent <span class='rfc2119'>SHOULD</span> allow the user to configure the display of matching payment apps to control the ordering and define preselected defaults.</li>
    </ul>

    <p>For recommended payment apps:</p>
    <ul>
      <li>The user agent <span class='rfc2119'>SHOULD</span> display recommended payment apps and allow configuration to not display recommended payment apps.</li>
      <li>The user agent <span class='rfc2119'>MUST</span> distinguish recommended payment apps from registered payment apps.</li>
      <li>The user agent <span class='rfc2119'>SHOULD</span> display any merchant-recommended apps in the order specified by the payee.</li>
    </ul>

    <div class="issue" title="Payment app selection user experience consistency">
        <p>We have identified a number of <a href="https://github.com/w3c/webpayments/wiki/PaymentApp_Notes#user-experience-descriptions">user experiences</a> that we would like to harmonize. Just a few examples here:</p>
        <ol>
          <li>User has no registered payment apps.</li>
          <li>User has apps with supported but no enabled payment methods.</li>
          <li>User has apps with supported and enabled payment methods.</li>
          <li>Merchant wishes to recommend a payment app to the user.</li>
          <li>User agent wishes to recommend a payment app that supports a payment method for which the user does not
              currently have a supporting payment app.</li>
        </ol>
    </div>

    <section class="informative">
      <h4>Examples of Ordering of Selectable Payment Apps</h4>
      <p>The following are examples of user agent ordering of selectable payment apps.</p>
      <ul>
	<li>For a given Web site, display payment apps in an order that reflects usage patterns for the site (e.g., a frequently used payment app at the top, or the most recently used payment app at the top).</li>
	<li>Enable the user to set a preferred order for a given site or for all sites.</li>
	<li>Display a payment app that is both registered by the user
	  and merchant-recommended at the top of a list.</li>
	<li>Display a payment app that is both registered by the user
	  and corresponds to the origin of the site being visited at the top of a list.</li>
      </ul>
    </section>
  </section>
  <section>
    <h3>Selection by the User</h3>
    <ul>
      <li>The user agent  <span class='rfc2119'>MUST</span> enable the user to
      select any <a>displayed payment app</a>.</li>
      <li>If the user selects an unregistered recommended payment app, the user agent <span class='rfc2119'>SHOULD</span>
          offer the user an opportunity to register it.</li>
    </ul>
  </section>
</section>
<section id="invocation">
  <h2>Payment App Invocation, Display and Response</h2>
  <p>
      Once the user has selected a payment app, the user agent is
      responsible for preparing <a>payment app request data</a>, invoking the
      payment app, providing the request data to the payment app, and
      returning the payment app response through the Payment Request API.
  </p>
  <section id="sec-app-request-data">
    <h3>Payment App Request Data</h3>
    The <a>payment app request data</a> is conveyed using the following
    dictionary:
    <pre class="idl">
      dictionary PaymentAppRequestData {
        DOMString origin;
        sequence&lt;PaymentMethodData&gt; methodData;
        PaymentItem total;
        sequence&lt;PaymentDetailsModifier&gt; modifiers;
        DOMString optionId;
      };
    </pre>
    <dl>
      <dt><code>origin</code> attribute</dt>
      <dd>
        This attribute a string that indicates the <a>origin</a> of the
        <a>payee</a> web page. It MUST be formatted according to the
        "<a href="https://tools.ietf.org/html/rfc6454#section-6.1">Unicode
        Serialization of an Origin</a>" algorithm defined in section 6.1 of
        [[!RFC6454]].
      </dd>
      <dt><code>methodData</code> attribute</dt>
      <dd>
        This attribute contains <code>PaymentMethodData</code>
        dictionaries containing the <a>payment method identifiers</a> for the
        <a>payment methods</a> that the web site accepts and any associated
        <a>payment method</a> specific data.
        It is populated from the
        <a>PaymentRequest</a> using the <a>Method Data Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>total</code> attribute</dt>
      <dd>
        This attribute indicates the total amount being requested for payment.
        It is initialized with a <a>structured clone</a> of the
        <code>total</code> field of the <code>PaymentDetails</code> provided
        when the corresponding <a>PaymentRequest</a> object was instantiated.
      </dd>
      <dd class="issue">Is the specification missing the top level "displayItems"?
      </dd>
      <dd class="issue">Keep an eye on <a href="https://github.com/w3c/browser-payment-api/issues/287">issue 287</a>. If the user agent generates a transaction ID, that ID must be passed to the payment app. If the merchant provides the transaction ID, that ID is already available through methodData.
      </dd>
      <dt><code>modifiers</code> attribute</dt>
      <dd>
        This sequence of <code>PaymentDetailsModifier</code> dictionaries
        contains modifiers for particular payment method identifiers (e.g.,
        if the payment amount or currency type varies based on a
        per-payment-method basis).  It is populated from the
        <a>PaymentRequest</a> using the <a>Modifiers Population Algorithm</a>
        defined below.
      </dd>
      <dt><code>optionId</code> attribute</dt>
      <dd>
        This attribute indicates the <a>PaymentAppOption</a> selected by
        the user. It corresponds to the <code>id</code> field provided during
        payment app registration.
      </dd>
    </dl>
    <section>
      <h3>
        <dfn>Method Data Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>methodData</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>dataList</var> to the newly created <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\methodData]]</var> in the
          corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inData</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inData</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentMethodData</code> object.
            </li>
            <li>
              Set <var>outData</var> to the newly created
              <code>PaymentMethodData</code>.
            </li>
            <li>
              Set <var>outData</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outData</var>.data to a <a>structured clone</a> of
              <var>inData</var>.<code>data</code>.
            </li>
            <li>
              Append <var>outData</var> to <var>dataList</var>.
            </li>
          </ol>
          <li>
            Set <code>methodData</code> to <var>dataList</var>.
          </li>
      </ol>
    </section>
    <section>
      <h3>
        <dfn>Modifiers Population Algorithm</dfn>
      </h3>
      <p>
        To initialize the value of the <code>modifiers</code>, the user agent
        MUST perform the following steps or their equivalent:
      </p>
      <ol>
        <li>
          Set <var>registeredMethods</var> to an empty set.
        </li>
        <li>
          For each <a>PaymentAppOption</a> <var>option</var> in the
          <a>payment app</a>'s <a>PaymentAppManifest</a>, add all entries in
          <var>option</var>.<code>enabledMethods</code> to
          <var>registeredMethods</var>.
        </li>
        <li>
          Create a new empty <code>Sequence</code>.
        </li>
        <li>
          Set <var>modifierList</var> to the newly created
          <code>Sequence</code>.
        </li>
        <li>
          For each item in
          <code>PaymentRequest</code>@<var>[[\paymentDetails]]</var>.<code>modifiers</code>
          in the corresponding payment request, perform the following steps:
          <ol>
            <li>
               Set <var>inModifier</var> to the item under consideration.
            </li>
            <li>
              Set <var>commonMethods</var> to the set intersection of
              <var>inModifier</var>.<code>supportedMethods</code>
              and <var>registeredMethods</var>.
            </li>
            <li>
              If <var>commonMethods</var> is empty, skip the remaining substeps
              and move on to the next item (if any).
            </li>
            <li>
              Create a new <code>PaymentDetailsModifier</code> object.
            </li>
            <li>
              Set <var>outModifier</var> to the newly created
              <code>PaymentDetailsModifier</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>supportedMethods</code> to
              a list containing the members of <var>commonMethods</var>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>total</code> to a <a>structured
              clone</a> of <var>inModifier</var>.<code>total</code>.
            </li>
            <li>
              Set <var>outModifier</var>.<code>additionalDisplayItems</code>
              to a <a>structured clone</a> of
              <var>inModifier</var>.<code>additionalDisplayItems</code>.
            </li>
            <li>
              Append <var>outModifier</var> to <var>modifierList</var>.
            </li>
          </ol>
          <li>
            Set <code>modifiers</code> to <var>modifierList</var>.
          </li>
      </ol>
    </section>
  </section>
  <section>
    <h3>Payment App Invocation</h3>
    <p>
      <a>Payment apps</a> are invoked when a <a>payee</a> requests a payment
      by calling <code>PaymentRequest.show()</code> and the user selects a
      payment app (or has one implicitly selected by previously established
      user preferences). If the user selects a <a>user agent-based payment
      app</a> to service the request, the <a>service worker</a> corresponding
      to that application receives an event with the
      <a>PaymentAppRequestData</a> containing information about the payment
      being requested. The event also contains a function that allows the
      payment app to provide a <a>payment response</a> back to the
      <a>payee</a>. This process is formally described in the following
      sections.
    </p>
    <section>
    <h3>
      Extension to <code>ServiceWorkerGlobalScope</code>
    </h3>
      <p>
        The Service Worker specification defines a
        <code>ServiceWorkerGlobalScope</code> interface [[!SERVICE-WORKERS]],
        which this specification extends.
      </p>
      <pre class="idl">
        partial interface ServiceWorkerGlobalScope {
          attribute EventHandler onpaymentrequest;
        };
      </pre>
      <dl>
        <dt><code>onpaymentrequest</code> attribute</dt>
        <dd>
          The <code>onpaymentrequest</code> attribute is an <a>event handler</a>
          whose corresponding <a>event handler event type</a> is
          <code>paymentrequest</code>.
        </dd>
      </dl>

      <p>The <a>PaymentRequestEvent</a> interface represents a received
      <a>payment request</a>.
    </section>
    <section>
    <h3>
      The <code>paymentrequest</code> Event
    </h3>
      <p>
        The <a>PaymentRequestEvent</a> represents a received <a>payment
        request</a>.
      </p>
      <pre class="idl">
      [Exposed=ServiceWorker]
      interface PaymentRequestEvent : ExtendableEvent {
        readonly attribute PaymentAppRequestData data;
        void respondWith(<a>Promise</a>&lt;<a>PaymentResponse</a>&gt;response);
      };
      </pre>
      <dl>
        <dt><code>data</code> attribute</dt>
        <dd>
          This attribute contains the <a>payment app request data</a> associated
          with this <a>payment request</a>.
        </dd>
        <dt><code>respondWith</code> method</dt>
        <dd>
          This method is used by the payment app to provide a
          <a>PaymentResponse</a> when the payment successfully completes.
        </dd>
      </dl>
        <p>
          Upon receiving a <a>payment request</a> by way of
          <code>PaymentRequest.show()</code> and subsequent user selection of a
          <a>user agent-based payment app</a>, the <a>user agent</a> MUST run
          the following steps or their equivalent:
        </p>
        <ol>
          <li>Let <var>registration</var> be the <a>service worker
          registration</a> corresponding to the <a>user agent-based payment app</a>
          selected by the user.
          </li>
          <li>If <var>registration</var> is not found and the selected app
            is a <a>recommended app</a>, register the service worker as described
            in <a href="#h-registration"></a>, skipping user consent and user
            agent registration for future use in <a href="#h-set-manifest"></a> (steps 9-11).
          </li>
          <li>If <var>registration</var> is not found, reject the Promise that
            was created by <code>PaymentRequest.show()</code> with a
            <a>DOMException</a> whose value "<a>InvalidStateError</a>" and
            terminate these steps.
          </li>
          <li>Invoke the <a>Handle Functional Event</a> algorithm with a
          <a>service worker registration</a> of <var>registration</var> and
          <var>callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object that was provided
                  as an argument.  </li>
              <li>Create a <a>trusted event</a>,
                  <var>e</var>, that uses the
                  <code><a>PaymentRequestEvent</a></code> interface, with the
                  event type <code>paymentrequest</code>, which does not bubble,
                  cannot be canceled, and has no default action.  </li>
              <li>Set the <code>data</code> attribute of
                  <var>e</var> to a new <a>PaymentAppRequestData</a> instance,
                  populated as described in
                  <a href="#sec-app-request-data"></a>.
              </li>
              <li>Dispatch <var>e</var> to <var>global</var>.</li>
              <li>Wait for all of the promises in the <a>extend lifetime
                  promises</a> of <var>e</var> to resolve.</li>
              <li>If the <a>payment app</a> has not provided a <a>payment app
                  response</a> as described in <a
                  href="#sec-payment-app-response"></a>, reject the Promise that
                  was created by <code>PaymentRequest.show()</code> with a
                  <a>DOMException</a> whose value "<a>OperationError</a>".
            </ol>
          </li>
        </ol>
    </section>
  </section>
  <section>
  <h3>
    Payment App Display
  </h3>
  <p>An invoked payment app may or may not choose to display information or request user input. For example:</p>
  <ul>
    <li>A payment app might always open a window so that the user can provide an authorization code.</li>
    <li>A payment app may open a window when first selected to pay during a session, but for subsequent payments in the same session, it might (through configuration) perform its duties without opening a window or requiring user interaction.</li>
    <li>The browser might support user configuration to streamline payments, such as "always use this payment app on this Web site" or "when there is just one matching payment app launch it automatically." Automatically invoked payment apps may wish to open windows without a recent explicit user action.</li>
    <li>A payment app that merely returns data might never need to open a window.</li>
  </ul>
  <p>To support scenarios that involve visual display and user interaction, user agents MUST allow payment apps to call the <code>clients.openWindow()</code> method defined in [[!SERVICE-WORKERS]].</p>
  <p>[[!SERVICE-WORKERS]] expects a user interaction to have occurred in order to open a Window. This user interaction is obvious when the user explicitly selects a payment app to make a payment. However, when user agent or payment app configuration allows payment app invocation without explicit user selection, the user agent MUST consider the <a>paymentrequest</a> event as the relevant user interaction for a <code>clients.openWindow()</code> request. See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/73">issue 73</a> for more discussion.</p>

  <p class="note">Implementations may vary on how windows open.
      For example, while opening an entirely new window is possible,
      it is more likely that the contents will be rendered in a way that makes
      it more obvious that the interactions pertain to the payment
      transaction. The opening of a <a>payment app window</a> versus
      other types of windows can be distinguished based on the event type the
      user agent is using to grant permission to open a window.
  </p>
  <div class="note">
    <p><em>The remainder of this section is currently a non-normative explanation of how
    the service worker <code>WindowClient</code> class can be used to interact
    with users.</em></p>
    <p>
      Upon calling clients.openWindow(), the payment app receives a
      <a>Promise</a> which resolves to a <code>WindowClient</code>. For the
      purposes of this discussion, we will refer to this
      <code>WindowClient</code> as <var>client</var>.  The payment app can use
      the <var>client</var>.<code>postMessage()</code> method to send messages
      to the <a>payment app window</a>.
    </p>
    <p>
      When a <a>payment app window</a> receives the <code>message</code> event
      from the payment app, this event will contain a <code>source</code>
      attribute which indicates the payment app's service worker. The payment
      app window can then call <code>source.postMessage()</code> to send a
      response to the payment app. Once the payment app window has complete its
      interaction with the user, it closes the window and uses this
      <code>postMessage()</code> call to return information to the payment app.
    </p>
    <p class="issue">
      In order for this approach to work, we have to treat a
      <a>paymentrequest</a> as permission to open a popup, which is a formal
      property relied up on by [[!SERVICE-WORKERS]]. We need to be careful
      that this does not become an end-run around exiting pop-up protections.
    </p>
    <p class="issue">
      Do we want to define a new <code>FrameType</code> for <a>payment app
      window</a>s? This requires input from someone with detailed knowledge of
      service worker design.
    </p>
    </div>
  </section>
  <section id="sec-payment-app-response">
    <h3>Payment App Response</h3>
    <p>
      The user agent receives a successful response from the payment app
      through resolution of the Promise provided to the <code>respondWith</code>
      function of the corresponding <a>PaymentRequestEvent</a> dictionary.
      The application is expected to resolve the Promise with a
      <code>PaymentResponse</code> dictionary instance containing the payment
      response information. In case of user cancellation or error, the
      application may signal failure by rejecting the Promise.
    </p>
    <p>
      If the Promise is rejected, the user agent MUST run the <dfn>payment app
      failure algorithm</dfn>. The exact details of this algorithm is left for
      user agent implementers to decide on. Acceptable behaviors include,
      but are not limited to:
    </p>
    <ul>
      <li>
        Letting the user try again, with the same payment app or with a
        different one.
      </li>
      <li>
        Rejecting the Promise that was created by
        <code>PaymentRequest.show()</code>.
      </li>
    </ul>
    <p>
      If this Promise is successfully resolved, the user agent MUST run the
      <a>user accepts the payment request algorithm</a> as defined in
      [[!PAYMENT-REQUEST-API]], replacing steps 6 and 7 with these steps or
      their equivalent:
    </p>
    <ol>
      <li>
        Set <var>appResponse</var> to the <code>PaymentResponse</code> used to
        resolve the <a>PaymentRequestEvent</a><code>.respondWith</code> Promise.
      </li>
      <li>
        If <var>appResponse</var>.<code>methodName</code> is not present or
        not set to one of the values from
        <a>PaymentRequestEvent</a>.<code>data</code>, run the <a>payment app
        failure algorithm</a> and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>methodName</code>
        and assign it to
        <var>response</var>.<code>methodName</code>.
      </li>
      <li>
        If <var>appResponse</var>.<code>details</code> is not present, run the
        <a>payment app failure algorithm</a> and terminate these steps.
      </li>
      <li>
        Create a <a>structured clone</a> of
        <var>appResponse</var>.<code>details</code>
        and assign it to
        <var>response</var>.<code>details</code>.
      </li>
    </ol>

    <p class="issue" title="Handling cancelation and failure">
      See <a href="https://github.com/w3c/webpayments-payment-apps-api/issues/37">issue 37</a> for discussion of payment app cancellation and also resulting user agent behavior. At the 23 November 2016 payment apps task force meeting, there was consensus that in case of payment app failure or cancelation, the user agent should not be prohibited from offering the user alternative matching payment apps.</p>

    <p>The following example shows how to respond to a payment request:</p>
    <pre class="example highlight" title="Sending a Payment Response">
      paymentRequestEvent.respondWith(new Promise(function(accept,reject) {
        /* ... processing may occur here ... */
        accept({
          methodName: "basic-card#visa",
          details: {
            card_number :  "1232343451234",
            expiry_month : "12",
            expiry_year :  "2020",
            cvv :          "123"
           }
        });
      });
    </pre>
     <p class="issue" title="Generic callback back-channel for the payment
     response transmission">
       Some payment methods might require a back channel to guarantee payment
       response delivery (especially push payment methods). See <a href="https://github.com/w3c/browser-payment-api/issues/224">issue 224</a>. [Ed Note:
       the "complete()" attribute of the "PaymentResponse" interface would serve
       this purpose quite cleanly.]
     </p>
  </section>
  <section id="post-example">
  <h3>Example using HTTP POST</h3>
    <p>
      This example codes shows how to use this API via a scheme in
      which a <code>POST</code> is sent to a URL with the payment request as a
      body. The response is allowed to be either <code>application/json</code>
      (which is inferred to contain a payment response), or
      <code>text/html</code> (which contains content to be rendered to the
      user).
    </p>
    <pre class="example highlight" title="Simple POST-based Payment App"
    id="example-post-payment-app">
      var contentType;
      var paymentPromise;
      /* Handle payment request from a payee */
      self.addEventListener('paymentrequest', function(e) {
        paymentPromise = new Promise(function(accept, reject) {
          fetch("https://www.example.com/bobpay/process",
            { method: "POST",  body: JSON.stringify(e.data) })
          .then(function(response) {
            contentType = response.headers.get("content-type");
            if (!contentType) {
              throw new Error("No content type header");
            }
            return response.text();
          }).then(function(body) {
            if(contentType.indexOf("application/json") !== -1) {
              /* Respond to the payment request with the received body */
              accept(JSON.parse(body));
            } else if (contentType.indexOf("text/html") !== -1) { {
              /* Open a new payment window and populate it with the
                 document returned from the response */
              var url = "data:text/html;base64," + btoa(body);
              clients.openWindow(url).then(function(windowClient) {
                windowClient.postMessage(e.data);
              });
            } else {
              throw new Error("Unexpected value in content type header");
            }
          }).catch(function(err) {
            reject(err);
          });
        e.respondWith(paymentPromise);
      });

      /* Handle payment response from a payment app window */
      self.addEventListener('message', function(e) {
        if (e.data.hasOwnProperty('name')) {
          paymentPromise.reject(e.data);
        } else {
          paymentPromise.resolve(e.data);
        }
      });
    </pre>
    <p>Using the simple scheme described above, a trivial HTML page that is
    loaded into the <a>payment app window</a> to implement the <em>basic
    card</em> scheme might look like the following:</p>
    <pre class="example highlight" title="Simple Payment App Window">
&lt;html&gt; &lt;body&gt; &lt;form id="form"&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Card Number:&lt;/th&gt;&lt;td&gt;&lt;input name="card_number"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Month:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_month"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Year:&lt;/th&gt;&lt;td&gt;&lt;input name="expiry_year"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;CVV:&lt;/th&gt;&lt;td&gt;&lt;input name="cvv"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="submit" value="Pay"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;script&gt;
window.addEventListener("message", function(e) {
  var form = document.getElementById("form");
  /* Note: message sent from payment app is available in e.data */
  form.onsubmit = function() {
    var details = {};
    ["card_number","expiry_month","expiry_year","cvv"].forEach(function(field) {
      details[field] = form.elements[field].value;
    });
    e.source.postMessage({
      methodName: "basic-card#visa",
      details: details
    });
    window.close();
  }
});
&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;
    </pre>

  </section>

</section>
<section id="security">
  <h2>Security and Privacy Considerations</h2>
  <section>
    <h3>Design Considerations</h3>
    <ul>
      <li>The API does not share information about the user's registered payment methods or payment apps with the payee. The only information that is shared is the result of user selection.</li>
    </ul>
  </section>
  <section>
    <h3>Secure Communications</h3>
    <ul>
      <li>See <a href="https://www.w3.org/TR/service-workers/#security-considerations">Service Worker security considerations</a></li>
      <li>Payment method security is outside the scope of this specification and is addressed by payment apps that support those payment methods.</li>
    </ul>
  </section>
  <section>
    <h3>Payment App Authenticity</h3>
    <ul>
      <li>To avoid problems such as phishing-type attacks on payee sites, we want to be able to ensure the authenticity of payment apps. In general we expect to rely on origin information for establishing payment app authenticity. In contexts where payment apps are referenced other than on their origin, we are considering additional measures to help establish authenticity. Examples: validate a digital signature prior to launching a recommended app or an installed native app without associated origin information.</li>
    </ul>
  </section>
  <section>
    <h3>Data Validation</h3>
    <ul>
      <li>Payees should validate that the data they have received through the paymentRequest API is what they expect (e.g., the total that was paid, etc.).</li>
    </ul>
  </section>
  <section>
    <h3>Private Browsing Mode</h3>
    <ul>
      <li>When the Payment Request API is invoked in a "private browsing mode," the user agent should launch user agent-based payment apps in a private context. This will generally prevent sites from accessing any previously-stored information. In turn, this is likely to require either that the user log in to the payment app or re-enter payment instrument details.</li>
    </ul>
  </section>
</section>
</body>
</html>
