<!DOCTYPE html>
<html>
  <head>
    <title>
      Payment Handler API
    </title>
    <meta charset='utf-8'>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class=
    'remove'></script>
    <script src='utils.js' class='remove'></script>
    <script class='remove'>
        var respecConfig = {
            shortName:  "webpayments-payment-handler",
            edDraftURI:   "https://w3c.github.io/webpayments-payment-handler/",
            specStatus: "ED",
            editors: [
                {   name:       "Adrian Hope-Bailie",
                    url:        "https://github.com/adrianhopebailie",
                    company:    "Ripple",
                    companyURL: "https://ripple.com"
                },
                {   name:       "Tommy Thorsen",
                    url:        "https://github.com/tommythorsen",
                    company:    "Opera",
                    companyURL: "https://opera.com"
                },
                {   name:       "Adam Roach",
                    url:        "https://github.com/adamroach",
                    company:    "Mozilla",
                    companyURL: "https://mozilla.org"
                },
                {   name:       "Jason Normore",
                    url:        "https://github.com/jnormore",
                    company:    "Shopify",
                    companyURL: "https://shopify.com"
                },
                {   name:       "Ian Jacobs",
                    url:        "http://www.w3.org/People/Jacobs/",
                    company:    "W3C",
                    companyURL: "https://www.w3.org/"
                },
            ],

            useExperimentalStyles: true,
            license:      "w3c-software-doc",

            wg:           "Web Payments Working Group",
            wgURI:        "https://www.w3.org/Payments/WG/",
            wgPublicList: "public-payments-wg",
            wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/83744/status",

            issueBase:    "https://github.com/w3c/webpayments-payment-handler/issues/",
            githubAPI:    "https://api.github.com/repos/w3c/webpayments-payment-handler",

            localBiblio:  {
                "PAYMENT-REQUEST-API": {
                    title:    "Payment Request API",
                    href:     "http://www.w3.org/TR/payment-request/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurray"
                    ],
                    status:   "WD"
                },
                "METHOD-IDENTIFIERS": {
                    title:    "Payment Method Identifiers",
                    href:     "https://www.w3.org/TR/payment-method-id/",
                    authors:  [
                        "Adrian Bateman",
                        "Zach Koch",
                        "Roy McElmurry"
                    ],
                    status:   "WD"
                }
            }
        };
    </script>
    <style>
        dt { margin-top: 0.75em; }
        table { margin-top: 0.75em; border-collapse:collapse; border-style:hidden hidden none hidden }
        table thead { border-bottom:solid }
        table tbody th:first-child { border-left:solid }
        table td, table th { border-left:solid; border-right:solid; border-bottom:solid thin; vertical-align:top; padding:0.2em }
        li { margin-top: 0.5em; margin-bottom: 0.5em;}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        Payment Request API [[!PAYMENT-REQUEST-API]] provides a standard way to
        initiate payment requests from Web pages and applications. User agents
        implementing that API prompt the user to select a way to handle the
        payment request, after which the user agent returns a payment response
        to the originating site. This specification defines capabilities that
        enable Web applications to handle payment requests.
      </p>
    </section>
    <section id='sotd'>
      <p>
        The Web Payments Working Group maintains <a href=
        "https://github.com/w3c/webpayments-payment-apps-api/issues">a list of
        all bug reports that the group has not yet addressed</a>. This draft
        highlights some of the pending issues that are still to be discussed in
        the working group. No decision has been taken on the outcome of these
        issues including whether they are valid. Pull requests with proposed
        specification text for outstanding issues are strongly encouraged.
      </p>
    </section>
    <section class='informative'>
      <h2>
        Introduction
      </h2>
      <p>
        The Web Payments Working Group seeks to streamline payments on the Web
        to help reduce "shopping cart abandonment" and make it easier to deploy
        new payment methods on the Web. It has published the Payment Request
        API [[!PAYMENT-REQUEST-API]] as a standard way to initiate payment
        requests from E-Commerce Web sites and applications.
      </p>
      <p>
        A <dfn>payment app</dfn> is a Web application that handles payment
        requests on behalf of the user by supporting one or more payment
        methods. To enable a Web application to handle payment requests, this
        specification defines:
      </p>
      <ul>
        <li>How payment apps request permission to handle payment requests on
        the user's behalf.
        </li>
        <li>How payment apps register their support for different payment
        methods with the user agent.
        </li>
        <li>How payment apps provide information to the user agent, to
        faciliate the display of choices for selection by the user, that
        determine which payment apps are invoked, to handle a payment request.
        </li>
        <li>How user agents invoke and exchange data with payment handlers from
        a payment app.
        </li>
      </ul>
      <p>
        This specification does not address how software built with
        operating-system specific mechanisms (e.g., "native mobile apps")
        handle payment requests.
      </p>
    </section>
    <section id='conformance'>
      <p>
        This specification defines one class of products:
      </p>
      <dl>
        <dt>
          <dfn>Conforming user agent</dfn>
        </dt>
        <dd>
          <p>
            A <a>user agent</a> MUST behave as described in this specification
            to be considered conformant. In this specification, <dfn>user
            agent</dfn> means a <em>Web browser or other interactive user
            agent</em> as defined in [[!HTML5]].
          </p>
          <p>
            User agents MAY implement algorithms given in this specification in
            any way desired, so long as the end result is indistinguishable
            from the result that would be obtained by the specification's
            algorithms.
          </p>
          <p>
            A conforming Payment Handler API user agent MUST also be a
            <em>conforming implementation</em> of the IDL fragments of this
            specification, as described in the “Web IDL” specification.
            [[!WEBIDL]]
          </p>
          <aside class="note">
            This specification uses both the terms "conforming user agent(s)"
            and "user agent(s)" to refer to this product class.
          </aside>
        </dd>
      </dl>
    </section>
    <section id="dependencies">
      <h2>
        Dependencies
      </h2>
      <p>
        This specification relies on several other underlying specifications.
      </p>
      <dl>
        <dt>
          Payment Request API
        </dt>
        <dd>
          The terms <dfn data-cite=
          "!PAYMENT-REQUEST-API#payment-method">payment method</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#dom-paymentrequest">PaymentRequest</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#dom-paymentresponse">PaymentResponse</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#dom-paymentmethoddata-supportedmethods">supportedMethods</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#paymentdetailsmodifier-dictionary">paymentDetailsModifier</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#paymentdetailsinit-dictionary">paymentDetailsInit</dfn>,
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#paymentmethoddata-dictionary">PaymentMethodData</dfn>,
          <dfn data-cite="!PAYMENT-REQUEST-API#id-attribute">ID</dfn>,
          <dfn data-cite="!PAYMENT-REQUEST-API#show-method">show()</dfn>, and
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#user-accepts-the-payment-request-algorithm">user
          accepts the payment request algorithm</dfn> are defined by the
          Payment Request API specification [[!PAYMENT-REQUEST-API]].
        </dd>
        <dt>
          ECMA-262 6th Edition, The ECMAScript 2015 Language Specification
        </dt>
        <dd>
          The terms <dfn data-cite=
          "!ECMA-262-2015#sec-promise-objects">Promise</dfn>, <dfn data-cite=
          "!ECMA-262-2015#sec-object-internal-methods-and-internal-slots">internal
          slot</dfn>, <code><dfn data-cite=
          "!ECMA-262-2015#sec-native-error-types-used-in-this-standard-typeerror">
          TypeError</dfn></code>, and <code><dfn data-cite=
          "!ECMA-262-2015#sec-json.stringify">JSON.stringify</dfn></code> are
          defined by [[!ECMA-262-2015]].
          <p>
            The term <dfn data-lt=
            "JSON-serialized|JSON-serializable">JSON-serialize</dfn> applied to
            a given object means to run the algorithm specified by the original
            value of the <a>JSON.stringify</a> function on the supplied object,
            passing the supplied object as the sole argument, and return the
            resulting string. This can throw an exception.
          </p>
        </dd>
        <dt>
          Payment Method Identifiers
        </dt>
        <dd>
          The terms <dfn data-lt="payment method identifiers">payment method
          identifier</dfn> is defined by the Payment Method Identifier
          specification [[!METHOD-IDENTIFIERS]].
        </dd>
        <dt>
          Basic Card Payment
        </dt>
        <dd>
          The terms <dfn data-cite=
          "!PAYMENT-REQUEST-API#method-id">basic-card</dfn>, <dfn data-cite=
          "!PAYMENT-REQUEST-API#supportedNetworks">supportedNetworks</dfn>, and
          <dfn data-cite=
          "!PAYMENT-REQUEST-API#supportedTypes">supportedTypes</dfn> are
          defined in [[!PAYMENT-METHOD-BASIC-CARD]].
        </dd>
        <dt>
          HTML5
        </dt>
        <dd>
          The terms <dfn data-cite="!HTML5#global-object">global object</dfn>,
          <dfn data-cite="!HTML5#top-level-browsing-context">top-level browsing
          context</dfn>, <dfn data-cite="!HTML5#structured-clone">structured
          clone</dfn>, <dfn data-cite="!HTML5#event-handlers">event
          handler</dfn>, <dfn data-cite="!HTML5#event-handler-event-type">event
          handler event type</dfn>, <dfn data-cite=
          "!HTML5#concept-events-trusted">trusted event</dfn>, and
          <dfn data-cite="!HTML5#user-interaction-task-source">user interaction
          task source</dfn> are defined by [[!HTML5]].
        </dd>
        <dt>
          RFC6454
        </dt>
        <dd>
          The term <dfn>origin</dfn> is defined in [[!RFC6454]].
        </dd>
        <dt>
          DOM
        </dt>
        <dd>
          The term <dfn data-cite="!DOM4#firing-events">fires</dfn> (an event)
          is defined in [[!DOM4]].
        </dd>
        <dt>
          Web IDL
        </dt>
        <dd>
          <p>
            <dfn data-cite="!WEBIDL-LS#dfn-DOMException">DOMException</dfn> and
            the following <a>DOMException</a> types from [[!WEBIDL-LS]] are
            used:
          </p>
          <ul>
            <li>"<code><dfn data-cite=
            "!WEBIDL-LS#invalidstateerror">InvalidStateError</dfn></code>"
            </li>
            <li>"<code><dfn data-cite=
            "!WEBIDL-LS#notfounderror">NotFoundError</dfn></code>"
            </li>
            <li>"<code><dfn data-cite=
            "!WEBIDL-LS#operationerror">OperationError</dfn></code>"
            </li>
            <li>"<code><dfn data-cite=
            "!WEBIDL-LS#securityerror">SecurityError</dfn></code>"
            </li>
          </ul>
        </dd>
        <dt>
          Secure Contexts
        </dt>
        <dd>
          The term <dfn data-cite="!SECURE-CONTEXTS#secure-context">secure
          context</dfn> is defined by the Secure Contexts specification
          [[!SECURE-CONTEXTS]].
        </dd>
        <dt>
          Service Workers
        </dt>
        <dd>
          The terms <dfn data-cite=
          "!SERVICE-WORKERS#service-worker-concept">service worker</dfn>,
          <dfn data-cite="!SERVICE-WORKERS#dfn-service-worker-client">service
          worker client</dfn>, <code><dfn data-cite=
          "!SERVICE-WORKERS#service-worker-registration-concept">ServiceWorkerRegistration</dfn></code>,
          <code><dfn data-cite=
          "!SERVICE-WORKERS#service-worker-global-scope">ServiceWorkerGlobalScope</dfn></code>,
          <dfn data-cite=
          "!SERVICE-WORKERS#handle-functional-event-algorithm">handle
          functional event</dfn>, <dfn data-cite=
          "!SERVICE-WORKERS#dfn-extend-lifetime-promises">extend lifetime
          promises</dfn>, and <dfn data-cite=
          "!SERVICE-WORKERS#dfn-scope-url">scope URL</dfn> are defined in
          [[!SERVICE-WORKERS]].
        </dd>
      </dl>
    </section>
    <section id="model">
      <h2>
        Overview of Handling Payment Requests
      </h2>
      <p>
        A <dfn>Payment Handler</dfn> is a function registered by the user with
        the user agent to handle <a>PaymentRequestEvent</a>s.
      </p>
      <p class="issue" title="Payment Manager / Handler" data-number="127">
        The distinction between Payment Handler and Payment Manager is not
        clear. There is a proposal to remove the phrase Payment Manager from
        the spec, renaming the "PaymentManager" interface the "PaymentHandler"
        interface.
      </p>
      <p>
        In this document we envision the following flow:
      </p>
      <ol>
        <li>An origin requests permission from the user to handle payment
        requests for a set of supported payment methods. For example, a user
        visiting a retail or bank site may be prompted to register a payment
        handler from that origin. The origin establishes the scope of the
        permission but the origin's capabilities may evolve without requiring
        additional user consent. Although from a permissions perspective there
        is a single Web app per origin, this specification provides mechanisms
        to origins for flexible structuring and display of <a data-lt=
        "PaymentManager.instruments">instruments</a> and <a data-lt=
        "PaymentManager.wallets">wallets</a>.
        </li>
        <li>Payment apps make use of <a>service worker</a>s which must define a
        <a>payment handler</a> to handle the <a>PaymentRequestEvent</a>s that
        are raised by the user agent.
        </li>
        <li>During registration the service worker will use the
        <a>PaymentManager</a> to set:
          <ul>
            <li>A list of <a data-lt="PaymentInstrument.enabledMethods">enabled
            payment methods</a>.
            </li>
            <li>[Optionally] the conditions under which the handler supports a
            given payment method; these <a data-lt=
            "PaymentInstrument.capabilities">capabilities</a> play a role in
            matching computations.
            </li>
            <li>Information for organizing the display and grouping of
            <a data-lt="PaymentManager.instruments">instruments</a> and
            <a data-lt="PaymentManager.wallets">wallets</a> supported by the
            payment handler.
            </li>
          </ul>
        </li>
        <li>When the merchant (or other <dfn>payee</dfn>) calls the
        [[PAYMENT-REQUEST-API]] method <a>show()</a> (e.g., when the user
        pushes a button on a checkout page), the user agent computes a list of
        candidate payment handlers, comparing the payment methods accepted by
        the merchant with those supported by registered payment handlers. For
        payment methods that support additional filtering, merchant and payment
        handler capabilities are compared as part of determining whether there
        is a match.
        </li>
        <li>The user agent displays a set of choices to the user. These choices
        are <a data-lt="PaymentManager.instruments">instruments</a> that were
        registered through the <a>PaymentManager</a> of candidate payment
        handlers, displaying and grouping the choices according to information
        (labels and icons) provided at registration or otherwise available from
        the Web app.
        </li>
        <li>When the user (the <dfn>payer</dfn>) selects an <a data-lt=
        "PaymentManager.instruments">instrument</a>, the user agent
        <a>fires</a> a <a>PaymentRequestEvent</a> (cf. the <a>user interaction
        task source</a>) in the service worker whose <a>PaymentManager</a> the
        instrument was registered with. The <a>PaymentRequestEvent</a> includes
        some information from the PaymentRequest (defined in
        [[!PAYMENT-REQUEST-API]]) as well as additional information (e.g.,
        origin and selected instrument).
        </li>
        <li>Once activated, the payment handler performs whatever steps are
        necessary to handle the payment request, and return an appropriate
        payment response to the <a>payee</a>. If interaction with the user is
        necessary, the <a>payment handler</a> can open a window for that
        purpose.
        </li>
        <li>The user agent receives a response asynchronously once the payment
        handler has finished handling the request. The response becomes the
        PaymentResponse (of [[!PAYMENT-REQUEST-API]]).
        </li>
      </ol>
      <p class="note">
        An origin may implement a payment app with more than one service worker
        and therefor multiple <a>payment handler</a>s may be registered per
        origin. The handler that is invoked is determined by the selection made
        by the user of a <a data-lt="PaymentManager.instruments">payment
        instrument</a>. The <a>service worker</a> which stored the <a data-lt=
        "PaymentManager.instruments">payment instrument</a> with its
        <a>PaymentManager</a> is the one that will be invoked.
      </p>
      <p>
        This specification does not address activities outside this flow,
        including:
      </p>
      <ul>
        <li>how the user establishes an account with an origin that provides
        payment services.
        </li>
        <li>how an origin authenticates a user.
        </li>
        <li>how communication takes place between the payee server and the
        payee Web application, or between a payment app origin and other
        parties.
        </li>
      </ul>
      <p>
        Thus, an origin will rely on many other Web technologies defined
        elsewhere for lifecycle management, security, user authentication, user
        interaction, and so on.
      </p>
      <section class="informative">
        <h2>
          Structure of a Web Payment App
        </h2>
        <figure>
          <img alt=
          "Architecture of a (Web) payment apps as defined in this specification."
          src="app-arch.png">
          <figcaption>
            A Web payment app is associated with an origin, and may be
            implemented by one or more payment handlers. A PaymentInstrument
            supports one or more payment methods. A PaymentWallet contains one
            or more PaymentInstrument and may be used to enhance the user
            experience (e.g., business wallet and personal wallet).
          </figcaption>
        </figure>
      </section>
      <section class="informative">
        <h2>
          Relation to Other Types of Payment Apps
        </h2>
        <p>
          This specification does not address how third-party mobile payment
          apps interact (through proprietary mechanisms) with user agents, or
          how user agents themselves provide simple payment app functionality.
        </p>
        <figure>
          <img alt=
          "Different types of payment apps. Payment Handler API is for Web apps."
          src="app-types.png">
          <figcaption>
            Payment Handler API enables Web apps to handle payments. Other
            types of payment apps may use other (proprietary) mechanisms.
          </figcaption>
        </figure>
      </section>
    </section>
    <section id="registration">
      <h2>
        Registration
      </h2>
      <section>
        <h2>
          Extension to the <code>ServiceWorkerRegistration</code> interface
        </h2>
        <p>
          This specification extends the <a>ServiceWorkerRegistration</a>
          interface with the addition of a <a>PaymentManager</a> attribute.
        </p>
        <pre class="idl">
        partial interface ServiceWorkerRegistration {
          readonly attribute PaymentManager paymentManager;
        };
      </pre>
        <p class="issue" title=
        "Do we need Payment Manager and Payment Handler?" data-number="127">
          The distinction is unclear. A proposal is to remove the phrase
          Payment Manager from the spec, renaming the "PaymentManager"
          interface the "PaymentHandler" interface.
        </p>
      </section>
      <section data-dfn-for="PaymentManager" data-link-for="PaymentManager">
        <h2>
          <dfn>PaymentManager</dfn> interface
        </h2>
        <pre class="idl">
      interface PaymentManager {
        [SameObject] readonly attribute PaymentInstruments instruments;
        [SameObject] readonly attribute PaymentWallets wallets;
                              Promise&lt;boolean&gt;   requestPermission();
      };
      </pre>
        <p>
          The <a>PaymentManager</a> is used by <a>payment app</a>s to manage
          their associated wallets, instruments and supported payment methods.
        </p>
        <section>
          <h2>
            <dfn>instruments</dfn> attribute
          </h2>
          <p>
            This attribute allows manipulation of payment instruments
            associated with a service worker (and therefor its payment
            handler). To be invoked by the user as part of the payment request
            flow, payment handlers must have at least one registered payment
            instrument to present to the user. That instrument needs to match
            the payment methods and required capabilities specified by the
            payment request.
          </p>
        </section>
        <section>
          <h2>
            <dfn>wallets</dfn> attribute
          </h2>
          <p>
            This attribute allows service workers to group payment instruments
            together and provide a name and icon for such a group (e.g., to
            group together "business account" payment instruments separately
            from "personal account" payment instruments). The use of this
            grouping mechanism by payment handlers is completely optional. If
            payment handlers use this grouping mechanism, then matching payment
            instruments that do not appear in any groups should still be
            presented to users by the user agent for selection.
          </p>
        </section>
        <section>
          <h2>
            <dfn>requestPermission</dfn> method
          </h2>
          <p class="issue" title="Permission" data-number="94">
            The means for code requesting permission to handle payments is not
            yet defined.
          </p>
          <p>
            The user agent is NOT REQUIRED to prompt the user to grant
            permission to the origin for each new supported payment method.
          </p>
        </section>
        <p class="issue" title=
        "Support grouped display of payment instruments?" data-number="98">
          Should the API support providing grouping information ("wallets") to
          the user agent? What should requirements be on user agents to display
          or provide for user interaction with this information?
        </p>
      </section>
      <section data-dfn-for="PaymentInstruments" data-link-for=
      "PaymentInstruments">
        <h2>
          <dfn>PaymentInstruments</dfn> interface
        </h2>
        <pre class="idl">
      interface PaymentInstruments {
          Promise&lt;boolean&gt;           delete(DOMString instrumentKey);
          Promise&lt;PaymentInstrument&gt; get(DOMString instrumentKey);
          Promise&lt;sequence&lt;DOMString&gt;&gt;  keys();
          Promise&lt;boolean&gt;           has(DOMString instrumentKey);
          Promise&lt;void&gt;              set(DOMString instrumentKey, PaymentInstrument details);
          Promise&lt;void&gt;           clear();
      };
      </pre>
        <p>
          The <a>PaymentInstruments</a> interface represents a collection of
          payment instruments, each uniquely identified by an
          <dfn>instrumentKey</dfn>. The <var>instrumentKey</var> identifier
          will be passed to the payment handler to indicate the
          <a>PaymentInstrument</a> selected by the user.
        </p>
        <section>
          <h2>
            <dfn>delete()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentInstrument</a> with
                a matching <var>instrumentKey</var>, remove it from the
                collection and resolve <var>p</var> with <b>true</b>.
                </li>
                <li>Otherwise, resolve <var>p</var> with <b>false</b>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>get()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentInstrument</a> with
                a matching <var>instrumentKey</var>, resolve <var>p</var> with
                that <a>PaymentInstrument</a>.
                </li>
                <li>Otherwise, reject <var>p</var> with a <a>DOMException</a>
                whose value is "<a>NotFoundError</a>".
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>keys()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>Resolve <var>p</var> with a <dfn>Sequence</dfn> that
                contains all the <var>instrumentKey</var>s for the
                <a>PaymentInstrument</a>s contained in the collection, in
                original insertion order.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>has()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentInstrument</a> with
                a matching <var>instrumentKey</var>, resolve <var>p</var> with
                <b>true</b>.
                </li>
                <li>Otherwise, resolve <var>p</var> with <b>false</b>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>set()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentInstrument</a> with
                a matching <var>instrumentKey</var>, replace it with the
                <a>PaymentInstrument</a> in <var>details</var>.
                </li>
                <li>Otherwise, insert the <a>PaymentInstrument</a> in
                <var>details</var> as a new member of the collection and
                associate it with the key <var>instrumentKey</var>.
                </li>
                <li>Resolve <var>p</var>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>clear()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>Remove all <a>PaymentInstrument</a>s from the collection
                and resolve <var>p</var>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
          <p class="issue" title="Clear()" data-number="129"></p>
        </section>
      </section>
      <section data-dfn-for="PaymentInstrument" data-link-for=
      "PaymentInstrument">
        <h2>
          <dfn>PaymentInstrument</dfn> dictionary
        </h2>
        <pre class="idl">
      dictionary PaymentInstrument {
        required DOMString name;
        sequence&lt;ImageObjects&gt; icons;
        sequence&lt;DOMString&gt; enabledMethods;
        object capabilities;
      };
      </pre>
        <dl>
          <dt>
            <dfn>name</dfn> member
          </dt>
          <dd>
            The <a>name</a> member is a string that represents the label for
            this <a>PaymentInstrument</a> as it is usually displayed to the
            user.
          </dd>
          <dt>
            <dfn>icons</dfn> member
          </dt>
          <dd>
            The <a>icons</a> member is an array of image objects that can serve
            as iconic representations of the payment instrument when presented
            to the user for selection.
          </dd>
          <dt>
            <dfn>enabledMethods</dfn> member
          </dt>
          <dd>
            The <a>enabledMethods</a> member is a list of one or more
            <a>payment method identifiers</a> of the <a>payment method</a>s
            supported by this instrument.
          </dd>
          <dt>
            <dfn>capabilities</dfn> member
          </dt>
          <dd>
            The <a>capabilities</a> member is a list of payment-method-specific
            capabilities that this payment handler is capable of supporting for
            this instrument. For example, for the <a>basic-card</a> payment
            method, this object will consist of an object with two fields: one
            for <a>supportedNetworks</a>, and another for
            <a>supportedTypes</a>.
          </dd>
        </dl>
        <p class="issue" title="ImageObjects not Defined" data-number="125">
          ImageObjects comes from the Web App Manifest specification. Should we
          reference the definition normatively, or make use of a simpler
          structure here?
        </p>
      </section>
      <section data-dfn-for="PaymentWallets" data-link-for="PaymentWallets">
        <h2>
          <dfn>PaymentWallets</dfn> interface
        </h2>
        <pre class="idl">
      interface PaymentWallets {
          Promise&lt;boolean&gt;       delete(DOMString walletKey);
          Promise&lt;PaymentWallet&gt; get(DOMString walletKey);
          Promise&lt;sequence&lt;DOMString&gt;&gt;  keys();
          Promise&lt;boolean&gt;       has(DOMString walletKey);
          Promise&lt;void&gt;          set(DOMString walletKey, PaymentWallet details);
          Promise&lt;void&gt;           clear();
      };
      </pre>
        <p>
          Wallets are collections of payment instruments.
        </p>
        <p>
          Where it appears, the <dfn>walletKey</dfn> argument is a unique
          identifier for the wallet.
        </p>
        <section>
          <h2>
            <dfn>delete()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentWallet</a> with a
                matching <var>walletKey</var>, remove it from the collection
                and resolve <var>p</var> with <b>true</b>.
                </li>
                <li>Otherwise, resolve <var>p</var> with <b>false</b>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>get()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentWallet</a> with a
                matching <var>walletKey</var>, resolve <var>p</var> with that
                <a>PaymentWallet</a>.
                </li>
                <li>Otherwise, reject <var>p</var> with a <a>DOMException</a>
                whose value is "<a>NotFoundError</a>".
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>keys()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>Resolve <var>p</var> with a sequence that contains all the
                <var>walletKey</var>s for the <a>PaymentWallet</a>s contained
                in the collection, in original insertion order.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>has()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentWallet</a> with a
                matching <var>walletKey</var>, resolve <var>p</var> with
                <b>true</b>.
                </li>
                <li>Otherwise, resolve <var>p</var> with <b>false</b>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>set()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>If the collection contains a <a>PaymentWallet</a> with a
                matching <var>walletKey</var>, replace it with the
                <a>PaymentWallet</a> in <var>details</var>.
                </li>
                <li>Otherwise, insert the <a>PaymentWallet</a> in
                <var>details</var> as a new member of the collection and
                associate it with the key <var>walletKey</var>.
                </li>
                <li>Resolve <var>p</var>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>clear()</dfn> method
          </h2>
          <p>
            When called, this method executes the following steps:
          </p>
          <ol>
            <li>Let <var>p</var> be a new promise.
            </li>
            <li>Run the following steps in parallel:
              <ol>
                <li>Remove all <a>PaymentWallets</a> from the collection and
                resolve <var>p</var>.
                </li>
              </ol>
            </li>
            <li>Return <var>p</var>
            </li>
          </ol>
          <p class="issue" title="Clear()" data-number="129"></p>
        </section>
      </section>
      <section data-dfn-for="PaymentWallet" data-link-for="PaymentWallet">
        <h2>
          <dfn>PaymentWallet</dfn> dictionary
        </h2>
        <pre class="idl">
      dictionary PaymentWallet {
          required DOMString name;
          sequence&lt;ImageObject&gt; icons;
          required sequence&lt;DOMString&gt; instrumentKeys;
      };
      </pre>
        <dl>
          <dt>
            <dfn>name</dfn> member
          </dt>
          <dd>
            The <a>name</a> member is a string that represents the label for
            this wallet as it is usually displayed to the user.
          </dd>
          <dt>
            <dfn>icons</dfn> member
          </dt>
          <dd>
            The <a>icons</a> member is an array of image objects that can serve
            as iconic representations of the wallet when presented to the user
            for selection.
          </dd>
          <dt>
            <dfn>instrumentKeys</dfn> member
          </dt>
          <dd>
            The <a>instrumentKeys</a> member is a list of one or more
            <a>instrumentKey</a>s from <a>PaymentManager</a>.<a data-lt=
            "PaymentManager.instruments">instruments</a>, indicating which
            <a>PaymentInstrument</a> objects are associated with this
            <a>Wallet</a>, and should be displayed as being "contained in" the
            wallet. While it is not generally good practice, there is no
            restriction that prevents a <a>PaymentInstrument</a> from appearing
            in more than one <a>Wallet</a>.
          </dd>
        </dl>
      </section>
      <section id="register-example" class="informative">
        <h2>
          Registration Example
        </h2>
        <p>
          The following example shows how to register a payment handler:
        </p>
        <p class="issue" title="Permission to Handle Payments" data-member=
        "94">
          <a data-lt=
          "PaymentManager.requestPermission()">requestPermission()</a> is not
          yet defined. The code below is based on one potential model, but this
          is likely to change.
        </p>
        <pre class="example js" title="Payment Handler Registration">
        window.addEventListerner("DOMContentLoaded", async() =&gt; {
          const { registration } =
            await navigator.serviceWorker.register('/sw.js');
          if (!paymentManager) {
            return; // not supported, so bail out.
          }
          const state =
            await navigator.permissions.query({ name: "paymenthandler" });

          switch (state) {
            case "denied":
              return;
            case "prompt":
              // Note -- it's not clear how this should work yet; see Issue 94.
              const result = await registration.paymentManager.requestPermission();
              if (result === "denied") {
                return;
              }
              break;
          }
          // Excellent, we got it! Let's now set up the user's cards.
          await addInstruments(registration);
        }, { once: true });

        function addInstruments(registration) {
          const instrumentPromises = [
            registration.paymentManager.instruments.set(
              "dc2de27a-ca5e-4fbd-883e-b6ded6c69d4f",
              {
                name: "Visa ending ****4756",
                enabledMethods: ["basic-card"],
                capabilities: {
                  supportedNetworks: ['visa'],
                  supportedTypes: ['credit']
                }
              }),

            registration.paymentManager.instruments.set(
              "c8126178-3bba-4d09-8f00-0771bcfd3b11",
              {
                name: "My Bob Pay Account: john@example.com",
                enabledMethods: ["https://bobpay.com/"]
              }),

            registration.paymentManager.instruments.set(
              "new-card",
              {
                name: "Add new credit/debit card to ExampleApp",
                enabledMethods: ["basic-card"],
                capabilities: {
                  supportedNetworks:
                    ['visa','mastercard','amex','discover'],
                  supportedTypes: ['credit','debit','prepaid']
                }
              }),
            ];

            return Promise.all(instrumentPromises).then(() =&gt; {
              registration.paymentManager.wallets.set(
                "12a1b7e5-16c0-4c09-a312-9b191d08517b",
                {
                  name: "Acme Bank Personal Accounts",
                  icons: [
                           { src: "icon/lowres.webp",
                             sizes: "48x48",
                             type: "image/webp"
                           },
                           { src: "icon/lowres",
                             sizes: "48x48"
                           }
                         ],
                  instrumentKeys: [
                      "dc2de27a-ca5e-4fbd-883e-b6ded6c69d4f",
                      "c8126178-3bba-4d09-8f00-0771bcfd3b11",
                      "new-card"
                    ]
                });
             });
          };
     </pre>
      </section>
    </section>
    <section id="instrument-display-ordering">
      <h2>
        Origin and Instrument Display for Selection
      </h2>
      <p>
        After applying the matching algorithm defined in Payment Request API,
        the user agent displays a list of instruments from matching payment
        apps for the user to make a selection. This specification includes a
        limited number of display requirements; most user experience details
        are left to implementers.
      </p>
      <section>
        <h2>
          Ordering of Payment Handlers
        </h2>
        <ul>
          <li>The user agent <span class='rfc2119'>MUST</span> favor user-side
          order preferences (based on user configuration or behavior) over
          payee-side order preferences.
          </li>
          <li>The user agent <span class='rfc2119'>MUST</span> display matching
          payment handlers in an order that corresponds to the order of
          supported payment methods provided by the payee, except where
          overridden by user-side order preferences.
          </li>
          <li>The user agent <span class='rfc2119'>SHOULD</span> allow the user
          to configure the display of matching payment handlers to control the
          ordering and define preselected defaults.
          </li>
        </ul>
        <p class="issue" title=
        "PR API payment method ordering and relation to this spec."
        data-number="116">
          The second bullet above may be deleted based on <a href=
          "https://github.com/w3c/browser-payment-api/issues/481">PR API issue
          481</a>.
        </p>
        <p>
          The following are examples of payment handler ordering:
        </p>
        <ul>
          <li>For a given Web site, display payment handlers in an order that
          reflects usage patterns for the site (e.g., a frequently used payment
          handler at the top, or the most recently used payment handler at the
          top).
          </li>
          <li>Enable the user to set a preferred order for a given site or for
          all sites.
          </li>
          <li>If the origin of the site being visited by the user matches the
          origin of a payment handler, show the payment handler at the top of
          the list.
          </li>
        </ul>
        <p class="issue" title="Merchant Preferences" data-number="74">
          The Working Group has discussed two types of merchant preferences
          related to payment apps: (1) highlighting merchant-preferred payment
          apps already registered by the user and (2) recommending payment apps
          not yet registered by the user. The current draft of the
          specification does not address either point, and the Working Group is
          seeking feedback on the importance of these use cases. Note that for
          the second capability, merchants can recommend payment apps through
          other mechanisms such as links from their web sites.
        </p>
      </section>
      <section>
        <h2>
          Display of Instruments
        </h2>
        <p>
          The user agent <span class='rfc2119'>MUST</span> enable the user to
          select any displayed instrument.
        </p>
        <ul>
          <li>At a minimum, we expect user agents to display an icon and label
          for each matching origin to help the user make a selection.
          </li>
          <li>In some contexts (e.g., a desktop browser) it may be possible to
          improve the user experience by offering additional detail to the
          user. For example, if the user's "bank.com" origin knows about two
          credit cards (thus, two potential responses to the same payment
          method "basic-card"), the user agent could display each credit card's
          brand and the last four digits of the card to remind the user which
          cards the origin knows about.
          </li>
        </ul>
        <p class="issue" title="Display" data-number="98">
          There has been push-back to always requiring display of instruments
          (e.g., on a mobile devices). User agents can incrementally show
          instruments. Or user agents can return an empty Instrument ID and it
          becomes the payment app's responsibility to display instruments to
          the user.
        </p>
      </section>
      <section>
        <h2>
          Grouping of Instruments
        </h2>
        <p>
          At times, the same origin may wish to group instruments with greater
          flexibility and granularity than merely "by origin." These use cases
          include:
        </p>
        <ul>
          <li>White label wallets - one origin provides wallet services for
          multiple vendors
          </li>
          <li>Multiple user profiles with a single provider (e.g., business
          wallet vs personal wallet)
          </li>
          <li>Multiple instruments held with a single provider
          </li>
        </ul>
        <p>
          A <dfn>Wallet</dfn> is a grouping of instruments for display
          purposes.
        </p>
        <p>
          To enable developers to build payment apps in a variety of ways, we
          decouple the registration (and subsequent display) of instruments
          from how payment handlers respond to a <a>PaymentRequestEvent</a>.
          However, the user agent is responsible for communicating the user's
          selection in the event.
        </p>
      </section>
      <section>
        <h2>
          Selection of Instruments
        </h2>
        <p>
          Users agents may wish to enable the user to select individual
          displayed Instruments. The payment handler would receive information
          about the selected Instrument and could take action, potentially
          eliminating an extra click (first open the payment app then select
          the Instrument).
        </p>
        <p class="issue" title="selection" data-number="98">
          Should we require that, if displayed, individual instruments must be
          selectable? Or should we allow flexibility that instruments may be
          displayed, but selecting any one invokes all registered payment
          handlers? One idea that has been suggested: the user agent (e.g., on
          a mobile device) could first display the app-level icon/logo. Upon
          selection, the user agent could display the Instruments in a submenu.
        </p>
      </section>
    </section>
    <section id="invocation">
      <h2>
        Invocation
      </h2>
      <p>
        Once the user has selected an Instrument, the user agent fires a
        <a>PaymentRequestEvent</a> with a <a>PaymentAppRequest</a>, and uses
        the subsequent <a>PaymentAppResponse</a> to create a PaymentReponse for
        [[!PAYMENT-REQUEST-API]].
      </p>
      <p class="issue" title=
      "Support for Abort() being delegated to Payment Handler" data-number=
      "117">
        Payment Request API supports delegation of responsibility to manage an
        abort to a payment app. There is a proposal to add a
        paymentRequestAborted event to the Payment Handler interface. The event
        will have a respondWith method that takes a boolean parameter
        indicating if the paymentRequest has been successfully aborted.
      </p>
      <section data-dfn-for="PaymentAppRequest" data-link-for=
      "PaymentAppRequest">
        <h2>
          <dfn>PaymentAppRequest</dfn> interface
        </h2>
        <pre class="idl">
      interface PaymentAppRequest {
        readonly attribute DOMString topLevelOrigin;
        readonly attribute DOMString paymentRequestOrigin;
        readonly attribute DOMString id;
        readonly attribute FrozenArray&lt;PaymentMethodData&gt; methodData;
        readonly attribute PaymentItem total;
        readonly attribute FrozenArray&lt;PaymentDetailsModifier&gt; modifiers;
        readonly attribute DOMString instrumentId;
      };
      </pre>
        <section>
          <h2>
            <dfn>topLevelOrigin</dfn> attribute
          </h2>
          <p>
            This attribute is a string that indicates the <a data-cite=
            "!HTML5#origin">origin</a> of the top level <a>payee</a> web page.
            The string MUST be formatted according to the "<a data-cite=
            "!RFC6454#section-6.1">Unicode Serialization of an Origin</a>"
            algorithm defined in section 6.1 of [[!RFC6454]].
          </p>
        </section>
        <section>
          <h2>
            <dfn>paymentRequestOrigin</dfn> attribute
          </h2>
          <p>
            This attribute is a string that indicates the <a data-cite=
            "!HTML5#origin">origin</a> where a <a>PaymentRequest</a> was
            initialized. When a <a>PaymentRequest</a> is initialized in the
            <a>topLevelOrigin</a>, the attributes have the same value,
            otherwise the attributes have different values. For example, when a
            <a>PaymentRequest</a> is initialized within an iframe from an
            origin other than <a>topLevelOrigin</a>, the value of this
            attribute is the origin of the iframe. The string MUST be formatted
            according to the "<a data-cite="!RFC6454#section-6.1">Unicode
            Serialization of an Origin</a>" algorithm defined in section 6.1 of
            [[!RFC6454]].
          </p>
        </section>
        <section>
          <h2>
            <dfn>id</dfn> attribute
          </h2>
          <p>
            When getting, the <a>id</a> attribute returns the
            [[\details]].<a>id</a> from the <a>PaymentRequest</a> that
            corresponds to this <a>PaymentAppRequest</a>.
          </p>
        </section>
        <section>
          <h2>
            <dfn>methodData</dfn> attribute
          </h2>
          <p>
            This attribute contains <a>PaymentMethodData</a> dictionaries
            containing the <a>payment method identifiers</a> for the <a>payment
            method</a>(s) that the web site accepts and any associated
            <a>payment method</a> specific data. It is populated from the
            <a>PaymentRequest</a> using the <a>MethodData Population
            Algorithm</a> defined below.
          </p>
        </section>
        <section>
          <h2>
            <dfn>total</dfn> attribute
          </h2>
          <p>
            This attribute indicates the total amount being requested for
            payment. It is initialized with a <a>structured clone</a> of the
            <a>total</a> field of the <a>PaymentDetailsInit</a> provided when
            the corresponding <a>PaymentRequest</a> object was instantiated.
          </p>
        </section>
        <section>
          <h2>
            <dfn>modifiers</dfn> attribute
          </h2>
          <p>
            This sequence of <a>PaymentDetailsModifier</a> dictionaries
            contains modifiers for particular payment method identifiers (e.g.,
            if the payment amount or currency type varies based on a
            per-payment-method basis). It is populated from the
            <a>PaymentRequest</a> using the <a>Modifiers Population
            Algorithm</a> defined below.
          </p>
        </section>
        <section>
          <h2>
            <dfn>instrumentId</dfn> attribute
          </h2>
          <p>
            This attribute indicates the <a>PaymentInstrument</a> selected by
            the user. It corresponds to the <a>id</a> field provided during
            registration.
          </p>
        </section>
        <section>
          <h2>
            <dfn>MethodData Population Algorithm</dfn>
          </h2>
          <p>
            To initialize the value of the <a>methodData</a>, the user agent
            MUST perform the following steps or their equivalent:
          </p>
          <ol>
            <li>Set <var>registeredMethods</var> to an empty set.
            </li>
            <li>For each <a>PaymentInstrument</a> <var>instrument</var> in the
            <a>payment handler</a>'s <a>PaymentManager</a>.<a data-lt=
            "PaymentManager.instruments">instruments</a>, add all entries in
            <var>instrument</var>.<a data-lt=
            "PaymentInstrument.enabledMethods">enabledMethods</a> to
            <var>registeredMethods</var>.
            </li>
            <li>Create a new empty <a>Sequence</a>.
            </li>
            <li>Set <var>dataList</var> to the newly created <a>Sequence</a>.
            </li>
            <li>For each item in
            <a>PaymentRequest</a>@<var>[[\methodData]]</var> in the
            corresponding payment request, perform the following steps:
              <ol>
                <li>Set <var>inData</var> to the item under consideration.
                </li>
                <li>Set <var>commonMethods</var> to the set intersection of
                <var>inData</var>.<a>supportedMethods</a> and
                <var>registeredMethods</var>.
                </li>
                <li>If <var>commonMethods</var> is empty, skip the remaining
                substeps and move on to the next item (if any).
                </li>
                <li>Create a new <a>PaymentMethodData</a> object.
                </li>
                <li>Set <var>outData</var> to the newly created
                <a>PaymentMethodData</a>.
                </li>
                <li>Set <var>outData</var>.<a>supportedMethods</a> to a list
                containing the members of <var>commonMethods</var>.
                </li>
                <li>Set <var>outData</var>.data to a <a>structured clone</a> of
                <var>inData</var>.data.
                </li>
                <li>Append <var>outData</var> to <var>dataList</var>.
                </li>
              </ol>
            </li>
            <li>Set <a>methodData</a> to <var>dataList</var>.
            </li>
          </ol>
        </section>
        <section>
          <h2>
            <dfn>Modifiers Population Algorithm</dfn>
          </h2>
          <p>
            To initialize the value of the <a>modifiers</a>, the user agent
            MUST perform the following steps or their equivalent:
          </p>
          <ol>
            <li>Set <var>registeredMethods</var> to an empty set.
            </li>
            <li>For each <a>PaymentInstrument</a> <var>instrument</var> in the
            <a>payment handler</a>'s <a>PaymentManager</a>.<a data-lt=
            "PaymentManager.instruments">instruments</a>, add all entries in
            <var>instrument</var>.<a data-lt=
            "PaymentInstrument.enabledMethods">enabledMethods</a> to
            <var>registeredMethods</var>.
            </li>
            <li>Create a new empty <a>Sequence</a>.
            </li>
            <li>Set <var>modifierList</var> to the newly created
            <a>Sequence</a>.
            </li>
            <li>For each item in
            <a>PaymentRequest</a>@<var>[[\paymentDetails]]</var>.<a>modifiers</a>
            in the corresponding payment request, perform the following steps:
              <ol>
                <li>Set <var>inModifier</var> to the item under consideration.
                </li>
                <li>Set <var>commonMethods</var> to the set intersection of
                <var>inModifier</var>.<a>supportedMethods</a> and
                <var>registeredMethods</var>.
                </li>
                <li>If <var>commonMethods</var> is empty, skip the remaining
                substeps and move on to the next item (if any).
                </li>
                <li>Create a new <a>PaymentDetailsModifier</a> object.
                </li>
                <li>Set <var>outModifier</var> to the newly created
                <a>PaymentDetailsModifier</a>.
                </li>
                <li>Set <var>outModifier</var>.<a>supportedMethods</a> to a
                list containing the members of <var>commonMethods</var>.
                </li>
                <li>Set <var>outModifier</var>.<a>total</a> to a <a>structured
                clone</a> of <var>inModifier</var>.<a>total</a>.
                </li>
                <li>Append <var>outModifier</var> to <var>modifierList</var>.
                </li>
              </ol>
            </li>
            <li>Set <a>modifiers</a> to <var>modifierList</var>.
            </li>
          </ol>
        </section>
      </section>
      <section data-dfn-for="ServiceWorkerGlobalScope" data-link-for=
      "ServiceWorkerGlobalScope">
        <h2>
          Extension to <a>ServiceWorkerGlobalScope</a>
        </h2>
        <p>
          This specification extends the <a>ServiceWorkerGlobalScope</a>
          interface.
        </p>
        <pre class="idl">
        partial interface ServiceWorkerGlobalScope {
          attribute EventHandler onpaymentrequest;
        };
        </pre>
        <section>
          <h2>
            <dfn>onpaymentrequest</dfn> attribute
          </h2>
          <p>
            The <a>onpaymentrequest</a> attribute is an <a>event handler</a>
            whose corresponding <a>event handler event type</a> is
            <a>paymentrequest</a>.
          </p>
        </section>
      </section>
      <section data-dfn-for="PaymentRequestEvent" data-link-for=
      "PaymentRequestEvent">
        <h2>
          The <dfn>PaymentRequestEvent</dfn>
        </h2>
        <p>
          The <a>PaymentRequestEvent</a> represents a received
          <a>PaymentRequest</a>.
        </p>
        <pre class="idl">
        [Exposed=ServiceWorker]
        interface PaymentRequestEvent : ExtendableEvent {
        readonly attribute PaymentAppRequest appRequest;
        Promise&lt;WindowClient&gt; openWindow(USVString url);
        void respondWith(Promise&lt;PaymentAppResponse&gt;appResponse);
        };
      </pre>
        <section>
          <h2>
            <dfn>appRequest</dfn> attribute
          </h2>
          <p>
            This attribute contains the <a>PaymentAppRequest</a> associated
            with this <a>PaymentRequest</a>.
          </p>
        </section>
        <section>
          <h2>
            <dfn>openWindow</dfn>() method
          </h2>
          <p>
            This method is used by the payment handler to show a window to the
            user. When called, it runs the <a>open window algorithm</a>.
          </p>
        </section>
        <section>
          <h2>
            <dfn>respondWith</dfn>() method
          </h2>
          <p>
            This method is used by the payment handler to provide a
            <a>PaymentAppResponse</a> when the payment successfully completes.
          </p>
        </section>
        <p class="issue" title="Share user data with payment app?" data-number=
        "123">
          Should payment apps receive user data stored in the user agent upon
          explicit consent from the user? The payment app could request
          permission either at installation or when the payment app is first
          invoked.
        </p>
        <p class="issue" title="DOM Events compatibility" data-number="119">
          For DOM events compatibility, need to add a constructor, and the
          members of the corresponding dictionary need to match the attributes
          of the event.
        </p>
      </section>
      <section>
        <h2>
          Internal Slots
        </h2>
        <p>
          Instances of <a>PaymentRequestEvent</a> are created with the internal
          slots in the following table:
        </p>
        <table>
          <tr>
            <th>
              Internal Slot
            </th>
            <th>
              Default Value
            </th>
            <th>
              Description (<em>non-normative</em>)
            </th>
          </tr>
          <tr>
            <td>
              <dfn>[[\windowClient]]</dfn>
            </td>
            <td>
              null
            </td>
            <td>
              The currently active <dfn>WindowClient</dfn>. This is set if a
              payment handler is currently showing a window to the user.
              Otherwise, it is null.
            </td>
          </tr>
        </table>
      </section>
      <section>
        <h2>
          Handling a PaymentRequestEvent
        </h2>
        <p>
          Upon receiving a <a>PaymentRequest</a> by way of <a data-cite=
          "!PAYMENT-REQUEST-API#show-method">PaymentRequest.show()</a> and
          subsequent user selection of a payment instrument, the <a>user
          agent</a> MUST run the following steps:
        </p>
        <ol>
          <li>Let <var>registration</var> be the
          <a>ServiceWorkerRegistration</a> corresponding to the <a>payment
          instrument</a> selected by the user.
          </li>
          <li>If <var>registration</var> is not found, reject the
          <a>Promise</a> that was created by <a data-cite=
          "!PAYMENT-REQUEST-API#show-method">PaymentRequest.show()</a> with a
          <a>DOMException</a> whose value is "<a>InvalidStateError</a>" and
          terminate these steps.
          </li>
          <li>Invoke the <a>handle functional event</a> algorithm with a
          <a>ServiceWorkerRegistration</a> of <var>registration</var> and <var>
            callbackSteps</var> set to the following steps:
            <ol>
              <li>Set <var>global</var> to the global object that was provided
              as an argument.
              </li>
              <li>Create a <a>trusted event</a>, <var>e</var>, that uses the
              <a>PaymentRequestEvent</a> interface, with the event type
              <a>paymentrequest</a>, which does not bubble, cannot be canceled,
              and has no default action.
              </li>
              <li>Set the <a data-lt=
              "PaymentRequestEvent.appRequest">appRequest</a> attribute of
              <var>e</var> to a new <a>PaymentAppRequest</a> instance using the
              <a>MethodData Population Algorithm</a> and the <a>Modifiers
              Population Algorithm</a>.
              </li>
              <li>Dispatch <var>e</var> to <var>global</var>.
              </li>
              <li>Wait for all of the promises in the <a>extend lifetime
              promises</a> of <var>e</var> to resolve.
              </li>
              <li>If the <a>payment handler</a> has not provided a
              <a>PaymentAppResponse</a> as described in <a href=
              "#sec-payment-app-response"></a>, reject the <a>Promise</a> that
              was created by <a data-cite=
              "!PAYMENT-REQUEST-API#show-method">PaymentRequest.show()</a> with
              a <a>DOMException</a> whose value "<a>OperationError</a>".
              </li>
            </ol>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h2>
        <dfn data-lt="payment handler window">Windows</dfn>
      </h2>
      <p>
        An invoked payment handler may or may not need to display information
        about itself or request user input. Some examples of potential payment
        handler displays include:
      </p>
      <ul>
        <li>The payment handler opens a window for the user to provide an
        authorization code.
        </li>
        <li>The payment handler opens a window that makes it easy for the user
        to confirm payment using default information for that site provided
        through previous user configuration.
        </li>
        <li>When first selected to pay in a given session, the payment handler
        opens a window. For subsequent payments in the same session, the
        payment handler (through configuration) performs its duties without
        opening a window or requiring user interaction.
        </li>
      </ul>
      <p>
        A <a>payment handler</a> that requires visual display and user
        interaction, may call openWindow() to display a page to the user.
      </p>
      <p class="note">
        Since user agents know that this method is connected to the
        <a>PaymentRequestEvent</a>, they SHOULD render the window in a way that
        is consistent with the flow and not confusing to the user. The
        resulting window client is bound to the tab/window that initiated the
        <a>PaymentRequest</a>. A single <a>payment handler</a> SHOULD NOT be
        allowed to open more than one client window using this method.
      </p>
      <section>
        <h2>
          <dfn>Open Window Algorithm</dfn>
        </h2>
        <p class="issue" title="The Open Window Algorithm" data-number="115">
          This algorithm resembles the <a data-cite=
          "!SERVICE-WORKERS#clients-openwindow">Open Window Algorithm</a> in
          the Service Workers specification.
        </p>
        <p class="issue" data-number="97">
          Should we refer to the Service Workers specification instead of
          copying their steps?
        </p>
        <ol class="algorithm">
          <li>Let <var>event</var> be this <a>PaymentRequestEvent</a>.
          </li>
          <li>Let <var>request</var> be the <a>PaymentRequest</a> that
          triggered this <a>PaymentRequestEvent</a>.
          </li>
          <li>If <var>request</var>.<a data-cite=
          "!PAYMENT-REQUEST-API#dfn-state-1">[[\state]]</a> is not
          "<a data-cite=
          "!PAYMENT-REQUEST-API#dfn-interactive">interactive</a>", then return
          a <a>Promise</a> rejected with a <a>DOMException</a> whose name is
          "<a>InvalidStateError</a>".
          </li>
          <li>Let <var>url</var> be the result of <a data-cite=
          "!whatwg-url#concept-url-parser">parsing</a> the <var>url</var>
          argument.
          </li>
          <li>If the url parsing throws an exception, return a <a>Promise</a>
          rejected with that exception.
          </li>
          <li>If <var>url</var> is <code>about:blank</code>, return a
          <a>Promise</a> rejected with a <a>TypeError</a>.
          </li>
          <li>Let <var>promise</var> be a new <a>Promise</a>.
          </li>
          <li>Run these steps <a data-cite="!whatwg-html#in-parallel">in
          parallel</a>:
            <ol>
              <li>Let <var>newContext</var> be a new <a data-cite=
              "!whatwg-html#top-level-browsing-context">top-level browsing
              context</a>.
              </li>
              <li>
                <a data-cite="!whatwg-html#navigate">Navigate</a>
                <var>newContext</var> to <var>url</var>, with exceptions
                enabled and replacement enabled.
              </li>
              <li>If the navigation throws an exception, reject
              <var>promise</var> with that exception and abort these steps.
              </li>
              <li>If the origin of <var>newContext</var> is not the same as the
              <a>service worker client</a> origin associated with the payment
              handler, then:
                <ol>
                  <li>Reject <var>promise</var> with a <a>DOMException</a>
                  whose name is "<a>SecurityError</a>".
                  </li>
                  <li>Abort these steps.
                  </li>
                </ol>
              </li>
              <li>Let <var>client</var> be the result of running the
              <a data-cite=
              "!SERVICE-WORKERS#capture-windowclient-algorithm">capture window
              client</a> algorithm with <var>newContext</var> as the argument.
              </li>
              <li>If <var>event</var>.<a>[[\windowClient]]</a> is not null,
              then:
                <ol>
                  <li>If
                    <var>event</var>.<a>[[\windowClient]]</a>.<a data-cite="!SERVICE-WORKERS#client-visibilitystate-attribute">visibilityState</a>
                    is not "unloaded", reject <var>promise</var> with a
                    <a>DOMException</a> whose name is
                    "<a>InvalidStateError</a>" and abort these steps.
                  </li>
                </ol>
              </li>
              <li>Set <var>event</var>.<a>[[\windowClient]]</a> to
              <var>client</var>.
              </li>
              <li>Resolve <var>promise</var> with <var>client</var>.
              </li>
            </ol>
          </li>
          <li>Return <var>promise</var>.
          </li>
        </ol>
      </section>
      <section id="post-example" class="informative">
        <h2>
          Example of handling the <a>PaymentRequestEvent</a>
        </h2>
        <p>
          This example shows how to write a service worker that listens to the
          <a>PaymentRequestEvent</a>. When a <a>PaymentRequestEvent</a> is
          received, the service worker opens a window to interact with the
          user.
        </p>
        <pre class="example js" title="Handling the PaymentRequestEvent">
      self.addEventListener('paymentrequest', function(e) {
        e.respondWith(new Promise(function(resolve, reject) {
          self.addEventListener('message', listener = function(e) {
            self.removeEventListener('message', listener);
            if (e.data.hasOwnProperty('name')) {
              reject(e.data);
            } else {
              resolve(e.data);
            }
          });

          e.openWindow("https://www.example.com/bobpay/pay")
          .then(function(windowClient) {
            windowClient.postMessage(e.data);
          })
          .catch(function(err) {
            reject(err);
          });
        }));
      });
      </pre>
        <p class="issue" title="Revisit examples" data-number="128">
          The Web Payments Working Group plans to revisit these two examples.
        </p>
        <p>
          Using the simple scheme described above, a trivial HTML page that is
          loaded into the <a>payment handler window</a> to implement the
          <em>basic card</em> scheme might look like the following:
        </p>
        <pre class="example html" title="Simple Payment Handler Window">
&lt;form id="form"&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;Cardholder Name:&lt;/th&gt;&lt;td&gt;&lt;input name="cardholderName"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Card Number:&lt;/th&gt;&lt;td&gt;&lt;input name="cardNumber"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Month:&lt;/th&gt;&lt;td&gt;&lt;input name="expiryMonth"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Expiration Year:&lt;/th&gt;&lt;td&gt;&lt;input name="expiryYear"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;Security Code:&lt;/th&gt;&lt;td&gt;&lt;input name="cardSecurityCode"&gt;&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="submit" value="Pay"&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/form&gt;

&lt;script&gt;
window.addEventListener("message", function(e) {
  var form = document.getElementById("form");
  /* Note: message sent from payment app is available in e.data */
  form.onsubmit = function() {
    /* See https://w3c.github.io/webpayments-methods-card/#basiccardresponse */
    var basicCardResponse = {};
    [ "cardholderName", "cardNumber","expiryMonth","expiryYear","cardSecurityCode"]
    .forEach(function(field) {
      basicCardResponse[field] = form.elements[field].value;
    });

    /* See https://w3c.github.io/webpayments-payment-apps-api/#sec-app-response */
    var paymentAppResponse = {
      methodName: "basic-card",
      details: details
    };

    e.source.postMessage(paymentAppResponse);
    window.close();
  }
});
&lt;/script&gt;
      </pre>
      </section>
    </section>
    <section>
      <h2>
        Response
      </h2>
      <section data-dfn-for="PaymentAppResponse" data-link-for=
      "PaymentAppResponse">
        <h2>
          <dfn>PaymentAppResponse</dfn> dictionary
        </h2>The PaymentAppResponse is conveyed using the following dictionary:
        <pre class="idl">
          dictionary PaymentAppResponse {
          DOMString methodName;
          object details;
          };
        </pre>
        <section>
          <h2>
            <dfn>methodName</dfn> attribute
          </h2>
          <p>
            The <a>payment method identifier</a> for the <a>payment method</a>
            that the user selected to fulfil the transaction.
          </p>
        </section>
        <section>
          <h2>
            <dfn>details</dfn> attribute
          </h2>
          <p>
            A <a>JSON-serializable</a> object that provides a <a>payment
            method</a> specific message used by the merchant to process the
            transaction and determine successful fund transfer.
          </p>
          <p>
            The user agent receives a successful response from the payment
            handler through resolution of the Promise provided to the
            <a data-lt="PaymentRequestEvent.respondWith">respondWith()</a>
            function of the corresponding <a>PaymentRequestEvent</a>
            dictionary. The application is expected to resolve the Promise with
            a <a>PaymentAppResponse</a> instance containing the payment
            response. In case of user cancellation or error, the application
            may signal failure by rejecting the Promise.
          </p>
          <p>
            If the Promise is rejected, the user agent MUST run the
            <dfn>payment app failure algorithm</dfn>. The exact details of this
            algorithm are left to implementers. Acceptable behaviors include,
            but are not limited to:
          </p>
          <ul>
            <li>Letting the user try again, with the same payment handler or
            with a different one.
            </li>
            <li>Rejecting the Promise that was created by <a data-cite=
            "!PAYMENT-REQUEST-API#show-method">PaymentRequest.show()</a>.
            </li>
          </ul>
        </section>
      </section>
      <section>
        <h2>
          Extention to User Accepts the Payment Request Algorithm
        </h2>
        <p>
          If the Promise is successfully resolved, the user agent MUST run the
          <a>user accepts the payment request algorithm</a> as defined in
          [[!PAYMENT-REQUEST-API]], replacing steps 6 and 7 with these steps or
          their equivalent:
        </p>
        <ol>
          <li>Set <var>appResponse</var> to the <a>PaymentAppResponse</a>
          instance used to resolve the <a>PaymentRequestEvent</a>.<a data-lt=
          "PaymentRequestEvent.respondWith">respondWith()</a> Promise.
          </li>
          <li>If <var>appResponse</var>.<a data-lt=
          "PaymentAppResponse.methodName">methodName</a> is not present or not
          set to one of the values from
            <a>PaymentRequestEvent</a>.<a data-lt="PaymentRequestEvent.appRequest">appRequest</a>,
            run the <a>payment app failure algorithm</a> and terminate these
            steps.
          </li>
          <li>Create a <a>structured clone</a> of
          <var>appResponse</var>.<a data-lt=
          "PaymentAppResponse.methodName">methodName</a> and assign it to <var>
            response</var>.<a data-lt=
            "PaymentAppResponse.methodName">methodName</a>.
          </li>
          <li>If <var>appResponse</var>.<var>details</var> is not present, run
          the <a>payment app failure algorithm</a> and terminate these steps.
          </li>
          <li>Create a <a>structured clone</a> of
          <var>appResponse</var>.<var>details</var> and assign it to
          <var>response</var>.<var>details</var>.
          </li>
        </ol>
        <p>
          The following example shows how to respond to a payment request:
        </p>
        <pre class="example js" title="Sending a Payment Response">
      paymentRequestEvent.respondWith(new Promise(function(accept,reject) {
        /* ... processing may occur here ... */
        accept({
          methodName: "basic-card",
          details: {
            cardHolderName:   "John Smith",
            cardNumber:       "1232343451234",
            expiryMonth:      "12",
            expiryYear :      "2020",
            cardSecurityCode: "123"
           }
        });
      });
          </pre>
        <p class="note">
          [[!PAYMENT-REQUEST-API]] defines an <a>ID</a> that parties in the
          ecosystem (including payment app providers and payees) may use for
          reconciliation after network or other failures.
        </p>
      </section>
    </section>
    <section id="security">
      <h2>
        Security and Privacy Considerations
      </h2>
      <section>
        <h2>
          Information about the User Environment
        </h2>
        <ul>
          <li>The API does not share information about the user's registered
          payment handlers. Information from origins is only shared with the
          payee with the consent of the user.
          </li>
          <li>Similarly, user agents should not share payment request
          information with any payment handler until the user has selected that
          payment handler.
          </li>
        </ul>
      </section>
      <section>
        <h2>
          User Consent before Payment
        </h2>
        <ul>
          <li>One goal of this specification is to minimize the user
          interaction required to make a payment. At the same time, user agents
          must not permit combinations of configurations that would enable
          invoking Web sites to invoke payment request and receive payments
          silently.
          </li>
        </ul>
      </section>
      <section>
        <h2>
          Secure Communications
        </h2>
        <ul>
          <li>See <a data-cite=
          "SERVICE-WORKERS#security-considerations">Service Worker security
          considerations</a>
          </li>
          <li>Payment method security is outside the scope of this
          specification and is addressed by payment handlers that support those
          payment methods.
          </li>
        </ul>
      </section>
      <section>
        <h2>
          Payment App Authenticity
        </h2>
        <p class="note">
          The Web Payments Working Group is also discussing Payment App
          authenticity; see the (draft) <a href=
          "https://w3c.github.io/webpayments/proposals/Payment-Manifest-Proposal.html">
          Payment Method Manifest</a>.
        </p>
      </section>
      <section>
        <h2>
          Data Validation
        </h2>
        <ul>
          <li>Payees should validate that the data they have received through
          the paymentRequest API is what they expect (e.g., the total that was
          paid, etc.).
          </li>
        </ul>
      </section>
      <section>
        <h2>
          Private Browsing Mode
        </h2>
        <ul>
          <li>When the Payment Request API is invoked in a "private browsing
          mode," the user agent should launch payment handlers in a private
          context. This will generally prevent sites from accessing any
          previously-stored information. In turn, this is likely to require
          either that the user log in to the origin or re-enter payment
          instrument details.
          </li>
        </ul>
      </section>
    </section>
    <section class="appendix" id="idl-index"></section>
  </body>
</html>
